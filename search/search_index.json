{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2 1.1. Introducci\u00f3n Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica. 1.2. Descripci\u00f3n del proyecto Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2. 1.3. Objetivos de proyecto - Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso. 1.4. Etapas del proyecto - Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos. Requisitos principales del proyecto - Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Home"},{"location":"#brazo-robotico-controlado-por-ros-2","text":"","title":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2"},{"location":"#11-introduccion","text":"Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica.","title":"1.1. Introducci\u00f3n"},{"location":"#12-descripcion-del-proyecto","text":"Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2.","title":"1.2. Descripci\u00f3n del proyecto"},{"location":"#13-objetivos-de-proyecto","text":"- Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso.","title":"1.3. Objetivos de proyecto"},{"location":"#14-etapas-del-proyecto","text":"- Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos.","title":"1.4. Etapas del proyecto"},{"location":"#requisitos-principales-del-proyecto","text":"- Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Requisitos principales del proyecto"},{"location":"2-0-Canal%20de%20referencia/","text":"2. Canal de referencia Para toda la elaboraci\u00f3n del proyecto, adem\u00e1s de utilizar librer\u00edas oficiales de las herramientas empleadas, se utilizaron videos de diversos canales de youtube. Sin embargo, para toda la conceptualizaci\u00f3n general de conocimientos para el proyecto, se emple\u00f3 el siguiente canal de youtube: Particularmente, se utiliz\u00f3 la siguiente la playlist Building a mobile robot . En este canal se realiza la simulaci\u00f3n y construcci\u00f3n de un robot diferencial; claramente al compararlo con el proyecto presentado tienen objetivos muy diferentes, pero al llevarse con las mismas herramientas y hasta por el mismo _camino_, se decidi\u00f3 tomar de referencia como conceptualizaci\u00f3n y hasta entrenamiento para la elaboraci\u00f3n del proyecto principal. Seg\u00fan esto, inicialmente se realiz\u00f3 el mismo proceso mostrado en el canal con el robot diferencial. Con esto realizado, se repitir\u00eda el mismo proceso pero con un servomotor; se tom\u00f3 este enfoque porque el SCARA est\u00e1 construido con _motores de paso_ con comportamiento similar a los servomotores; por lo que, al realizar el control con un servomotor, bastar\u00eda con _adaptar_ el proyecto al SCARA.","title":"2. Canal de referencia"},{"location":"2-0-Canal%20de%20referencia/#2-canal-de-referencia","text":"Para toda la elaboraci\u00f3n del proyecto, adem\u00e1s de utilizar librer\u00edas oficiales de las herramientas empleadas, se utilizaron videos de diversos canales de youtube. Sin embargo, para toda la conceptualizaci\u00f3n general de conocimientos para el proyecto, se emple\u00f3 el siguiente canal de youtube: Particularmente, se utiliz\u00f3 la siguiente la playlist Building a mobile robot . En este canal se realiza la simulaci\u00f3n y construcci\u00f3n de un robot diferencial; claramente al compararlo con el proyecto presentado tienen objetivos muy diferentes, pero al llevarse con las mismas herramientas y hasta por el mismo _camino_, se decidi\u00f3 tomar de referencia como conceptualizaci\u00f3n y hasta entrenamiento para la elaboraci\u00f3n del proyecto principal. Seg\u00fan esto, inicialmente se realiz\u00f3 el mismo proceso mostrado en el canal con el robot diferencial. Con esto realizado, se repitir\u00eda el mismo proceso pero con un servomotor; se tom\u00f3 este enfoque porque el SCARA est\u00e1 construido con _motores de paso_ con comportamiento similar a los servomotores; por lo que, al realizar el control con un servomotor, bastar\u00eda con _adaptar_ el proyecto al SCARA.","title":"2. Canal de referencia"},{"location":"3-0-Requisitos/","text":"3. Requisitos software Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"3. Requisitos software"},{"location":"3-0-Requisitos/#3-requisitos-software","text":"Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"3. Requisitos software"},{"location":"4-0-primerosPasosRos/","text":"4. Primeros pasos con ROS 4.1. Creando un paquete en ROS Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) . 4.2. Clonar un paquete de Github A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"4. Primeros pasos con ROS"},{"location":"4-0-primerosPasosRos/#4-primeros-pasos-con-ros","text":"","title":"4. Primeros pasos con ROS"},{"location":"4-0-primerosPasosRos/#41-creando-un-paquete-en-ros","text":"Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) .","title":"4.1. Creando un paquete en ROS"},{"location":"4-0-primerosPasosRos/#42-clonar-un-paquete-de-github","text":"A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"4.2. Clonar un paquete de Github"},{"location":"4-1-URDF/","text":"5. URDF Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_. 5.1. Setup Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot. 5.2. Ejemplo URDF con Robot diferencial Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba 5.2.1. Creando un archivo URDF En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF. 5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5. URDF"},{"location":"4-1-URDF/#5-urdf","text":"Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_.","title":"5. URDF"},{"location":"4-1-URDF/#51-setup","text":"Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot.","title":"5.1. Setup"},{"location":"4-1-URDF/#52-ejemplo-urdf-con-robot-diferencial","text":"Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba","title":"5.2. Ejemplo URDF con Robot diferencial"},{"location":"4-1-URDF/#521-creando-un-archivo-urdf","text":"En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF.","title":"5.2.1. Creando un archivo URDF"},{"location":"4-1-URDF/#53-ejemplo-servomotor-urdf-con-plugin-de-solidworks","text":"Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks"},{"location":"5-0-Servo/","text":"6. Servo Con los pasos requeridos para ejecutar el robot diferencial, se procedi\u00f3 a realizar el mismo proceso para un servomotor. Para esto, como bien se menciona anteriormente, se pueden utilizar dos m\u00e9todos: Constituir el servo con figuras volum\u00e9tricas b\u00e1sicas Extraer el URDF con el plugin de solidworks como se mostr\u00f3 en el ejemplo anterior. Un servomotor es un dispositivo que permite controlar con m\u00e1xima precisi\u00f3n la posici\u00f3n y movimiento de su eje. Esto quiere decir que se puede mover en un \u00e1ngulo, posici\u00f3n y a una velocidad determinada en cada momento, cosa que no puede hacer con normalidad un motor el\u00e9ctrico. Industrialmente, se utilizan los servos en todas aquellas aplicaciones de automatizaci\u00f3n industrial y rob\u00f3tica en las que se necesitan un exhaustivo control del par, del posicionamiento y de la velocidad para mejorar la calidad y la productividad. Los servomotores pueden ser industriales o de electr\u00f3nica b\u00e1sica, su principal diferencia son los l\u00edmites de rotaci\u00f3n que pueden llegar a tener, un servo industrial puede tener un giro de 360 grados sin problema, mientras un servo de electr\u00f3nica b\u00e1sica solamente tiene libertad de 180 grados. En este caso se estar\u00e1 trabajando con un servo de electr\u00f3nica b\u00e1sica como el siguiente: En terminos de mecanismos internos, un servo es un dispositivo que se puede modelar muy f\u00e1cilmente, solo contiene un chasis que ser\u00eda la caja azul y tendr\u00eda la parte superior que rota sobre un eje que se denomina como plumilla . Ante esta situaci\u00f3n, se decidi\u00f3 realizar toda la aplicaci\u00f3n del servo con figuras volum\u00e9tricas b\u00e1sicas, toda esta configuraci\u00f3n se encuentra en el siguiente enlace . En las siguientes p\u00e1ginas se explicar\u00e1 brevemente los pasos para controlar un servomotor que posee 1 DOF y el contenido del repositorio que contiene los c\u00f3digos utilizados en la soluci\u00f3n del problema. Se controla primeramente un servomotor con la intenci\u00f3n de entender c\u00f3mo funciona rob\u00f3ticamente ROS 2 y c\u00f3mo se controla cada grado de libertad, posteriormente se implementar\u00e1 lo aprendido para controlar el robot SCARA.","title":"6. Servo"},{"location":"5-0-Servo/#6-servo","text":"Con los pasos requeridos para ejecutar el robot diferencial, se procedi\u00f3 a realizar el mismo proceso para un servomotor. Para esto, como bien se menciona anteriormente, se pueden utilizar dos m\u00e9todos: Constituir el servo con figuras volum\u00e9tricas b\u00e1sicas Extraer el URDF con el plugin de solidworks como se mostr\u00f3 en el ejemplo anterior. Un servomotor es un dispositivo que permite controlar con m\u00e1xima precisi\u00f3n la posici\u00f3n y movimiento de su eje. Esto quiere decir que se puede mover en un \u00e1ngulo, posici\u00f3n y a una velocidad determinada en cada momento, cosa que no puede hacer con normalidad un motor el\u00e9ctrico. Industrialmente, se utilizan los servos en todas aquellas aplicaciones de automatizaci\u00f3n industrial y rob\u00f3tica en las que se necesitan un exhaustivo control del par, del posicionamiento y de la velocidad para mejorar la calidad y la productividad. Los servomotores pueden ser industriales o de electr\u00f3nica b\u00e1sica, su principal diferencia son los l\u00edmites de rotaci\u00f3n que pueden llegar a tener, un servo industrial puede tener un giro de 360 grados sin problema, mientras un servo de electr\u00f3nica b\u00e1sica solamente tiene libertad de 180 grados. En este caso se estar\u00e1 trabajando con un servo de electr\u00f3nica b\u00e1sica como el siguiente: En terminos de mecanismos internos, un servo es un dispositivo que se puede modelar muy f\u00e1cilmente, solo contiene un chasis que ser\u00eda la caja azul y tendr\u00eda la parte superior que rota sobre un eje que se denomina como plumilla . Ante esta situaci\u00f3n, se decidi\u00f3 realizar toda la aplicaci\u00f3n del servo con figuras volum\u00e9tricas b\u00e1sicas, toda esta configuraci\u00f3n se encuentra en el siguiente enlace . En las siguientes p\u00e1ginas se explicar\u00e1 brevemente los pasos para controlar un servomotor que posee 1 DOF y el contenido del repositorio que contiene los c\u00f3digos utilizados en la soluci\u00f3n del problema. Se controla primeramente un servomotor con la intenci\u00f3n de entender c\u00f3mo funciona rob\u00f3ticamente ROS 2 y c\u00f3mo se controla cada grado de libertad, posteriormente se implementar\u00e1 lo aprendido para controlar el robot SCARA.","title":"6. Servo"},{"location":"5-1-ServoXacros/","text":"7. Servo Xacros En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en servo REAL , para esto se utiliza como plugin los archivos de servo Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: Descripci\u00f3n general del robot, al haber sido realizada con geometr\u00edas b\u00e1sicas tambi\u00e9n se encuentran archivos como Inertial macros y Servo materials ; adem\u00e1s, al ser un repositorio que cuenta con la opci\u00f3n de simular el servo en Gazebo y luego realizar la aplcaci\u00f3n con el servo real, se encuentran dos archivos para cada una de estas: servo.simulated.xacro y servo.urdf.xacro respectivamente. 7.1. Gazebo xacro Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el servo se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del servo. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio la descripci\u00f3n de los colores del robot <?xml version=\"1.0\"?> <robot> <!-- Gazebo Colors --> <gazebo reference=\"motor\"> <material>Gazebo/Blue</material> </gazebo> <gazebo reference=\"arm\"> <material>Gazebo/White</material> </gazebo> Despu\u00e9s de esto se tiene la integraci\u00f3n con el hardware component, en donde se utiliza como plugin la opci\u00f3n de _GazeboSystem_ al ser el xacro el servo simulado, despu\u00e9s se describen los joints con los l\u00edmites y las `command interfaces` y `state interfaces`. <!-- Gazebo Hardware Component --> <ros2_control name=\"GazeboSystem\" type=\"system\"> <hardware> <plugin>gazebo_ros2_control/GazeboSystem</plugin> </hardware> <joint name=\"servo_joint\"> <command_interface name=\"position\"> <param name=\"min\">-1.58</param> <param name=\"max\">1.58</param> </command_interface> <state_interface name=\"position\"> <param name=\"initial_value\">0</param> </state_interface> <state_interface name=\"velocity\"/> <state_interface name=\"effort\"/> </joint> </ros2_control> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find servo_hardware)/config/servo_controllers_gazebo.yaml</parameters> </plugin> </gazebo> </robot> 7.2. ROS2 Control El xacro del ros2 Control se utiliza cuando se desea controlar el servo REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"servo_ros2_control\" params=\"name prefix\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>servo_hardware/ServoArduinoHardware</plugin> <param name=\"joint1_name\">servo_joint</param> <param name=\"loop_rate\">30</param> <param name=\"device\">/home/jammy/servo</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"enc_counts_per_rev\">3436</param> <param name=\"pid_p\">20</param> <param name=\"pid_d\">12</param> <param name=\"pid_i\">0</param> <param name=\"pid_o\">50</param> </hardware> <joint name=\"${prefix}servo_joint\"> <command_interface name=\"position\"/> <state_interface name=\"position\"/> <state_interface name=\"velocity\"/> </joint> </ros2_control> </xacro:macro> </robot> 7.3. URDF Como se menciona anteriormente, el URDF de este robot contiene distintos archivos xacro como las Inertial macros y Servo materials 7.3.1. Inertial Macros y Servo materials Estos archivos son bastante similares a los vistos en el ejemplo del robot diferencial, las Inertial macros siempre depender\u00e1n de la complejidad geom\u00e9trica del robot: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> Como se puede observar, es literalmente la misma macro empleada en el robot diferencial al utilizarse las mismas figur\u00e1s volum\u00e9tricas. Para la parte de los materiales del robot, tambi\u00e9n se realizaron de manera equivalente como en el robot diferencial: <?xml version=\"1.0\"?> <!-- Copied from ROS1 example: https://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/materials.xacro --> <robot> <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> </robot> 7.3.2. Servo description En el xacro de servo description se tiene TODO el URDF del servo empleado en el repositorio. Para esto primero se incluyen las macros previamente expuestas: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <xacro:include filename=\"$(find servo_hardware)/urdf/inertial_macros.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.materials.xacro\" /> Luego se empieza con la definici\u00f3n de los links y joints primero con el MOTOR o CHASIS del servo. <!-- BASE LINK --> <link name=\"base_link\" /> <joint name=\"fixation\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"motor\"/> <origin xyz=\"0 0 0.267\"/> </joint> <!-- MOTOR LINK --> <link name=\"motor\"> <visual> <origin xyz=\"0.0 0.0535 -0.1535\"/> <geometry> <box size=\"0.118 0.225 0.227\"/> </geometry> <material name=\"blue\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.025\"/> <geometry> <cylinder radius=\"0.059\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.063 -0.025\"/> <geometry> <cylinder radius=\"0.025\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.0535 -0.0955\"/> <geometry> <box size=\"0.118 0.319 0.025\"/> </geometry> </visual> <collision> <origin xyz=\"0.0 0.0535 -0.1335\"/> <geometry> <box size=\"0.118 0.319 0.267\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.15\" x=\"0.118\" y=\"0.319\" z=\"0.267\"> <origin xyz=\"0.0 0.0535 -0.1335\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> Y luego con el ARM del servo o PLUMILLA <!-- ARM LINK --> <joint name=\"servo_joint\" type=\"revolute\"> <limit lower=\"-${pi/2}\" upper=\"${pi/2}\" effort=\"0.0\" velocity=\"0.0\"/> <parent link=\"motor\"/> <child link=\"arm\"/> <origin xyz=\"0 0 0.042\" rpy=\"0 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"arm\"> <visual> <origin xyz=\"0.0 0.0 -0.027\"/> <geometry> <cylinder radius=\"0.023\" length=\"0.03\"/> </geometry> <material name=\"white\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.021\"/> <geometry> <cylinder radius=\"0.05\" length=\"0.054\"/> </geometry> </visual> <visual> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.254 0.08 0.02\"/> </geometry> </visual> <collision> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.304 0.08 0.02\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.023\" radius=\"0.05\" length=\"0.03\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> </robot> 7.4. Servo simulated y servo urdf Por \u00faltimo, se tienen dos xacros para las dos aplicaciones previamente mencionadas del robot 7.4.1. Servo simulated Este xacro se emplea \u00fanicamente para simular el servo en Gazebo , por lo que, en este archivo se incluyen los archivos necesarios para la simulaci\u00f3n; es decir, servo.description.xacro y servo.gazebo.xacro <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/gazebo/servo.gazebo.xacro\" /> </robot> 7.4.2. Servo urdf Y por otro lado, el servo.urdf.xacro incluye los archivos necesarios para realizar al aplicaci\u00f3n con el servo real ( servo.description.xacro y servo.ros2_control.xacro ) <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/ros2_control/servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" prefix=\"\" /> </robot>","title":"7. Servo Xacros"},{"location":"5-1-ServoXacros/#7-servo-xacros","text":"En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en servo REAL , para esto se utiliza como plugin los archivos de servo Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: Descripci\u00f3n general del robot, al haber sido realizada con geometr\u00edas b\u00e1sicas tambi\u00e9n se encuentran archivos como Inertial macros y Servo materials ; adem\u00e1s, al ser un repositorio que cuenta con la opci\u00f3n de simular el servo en Gazebo y luego realizar la aplcaci\u00f3n con el servo real, se encuentran dos archivos para cada una de estas: servo.simulated.xacro y servo.urdf.xacro respectivamente.","title":"7. Servo Xacros"},{"location":"5-1-ServoXacros/#71-gazebo-xacro","text":"Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el servo se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del servo. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio la descripci\u00f3n de los colores del robot <?xml version=\"1.0\"?> <robot> <!-- Gazebo Colors --> <gazebo reference=\"motor\"> <material>Gazebo/Blue</material> </gazebo> <gazebo reference=\"arm\"> <material>Gazebo/White</material> </gazebo> Despu\u00e9s de esto se tiene la integraci\u00f3n con el hardware component, en donde se utiliza como plugin la opci\u00f3n de _GazeboSystem_ al ser el xacro el servo simulado, despu\u00e9s se describen los joints con los l\u00edmites y las `command interfaces` y `state interfaces`. <!-- Gazebo Hardware Component --> <ros2_control name=\"GazeboSystem\" type=\"system\"> <hardware> <plugin>gazebo_ros2_control/GazeboSystem</plugin> </hardware> <joint name=\"servo_joint\"> <command_interface name=\"position\"> <param name=\"min\">-1.58</param> <param name=\"max\">1.58</param> </command_interface> <state_interface name=\"position\"> <param name=\"initial_value\">0</param> </state_interface> <state_interface name=\"velocity\"/> <state_interface name=\"effort\"/> </joint> </ros2_control> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find servo_hardware)/config/servo_controllers_gazebo.yaml</parameters> </plugin> </gazebo> </robot>","title":"7.1. Gazebo xacro"},{"location":"5-1-ServoXacros/#72-ros2-control","text":"El xacro del ros2 Control se utiliza cuando se desea controlar el servo REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"servo_ros2_control\" params=\"name prefix\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>servo_hardware/ServoArduinoHardware</plugin> <param name=\"joint1_name\">servo_joint</param> <param name=\"loop_rate\">30</param> <param name=\"device\">/home/jammy/servo</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"enc_counts_per_rev\">3436</param> <param name=\"pid_p\">20</param> <param name=\"pid_d\">12</param> <param name=\"pid_i\">0</param> <param name=\"pid_o\">50</param> </hardware> <joint name=\"${prefix}servo_joint\"> <command_interface name=\"position\"/> <state_interface name=\"position\"/> <state_interface name=\"velocity\"/> </joint> </ros2_control> </xacro:macro> </robot>","title":"7.2. ROS2 Control"},{"location":"5-1-ServoXacros/#73-urdf","text":"Como se menciona anteriormente, el URDF de este robot contiene distintos archivos xacro como las Inertial macros y Servo materials","title":"7.3. URDF"},{"location":"5-1-ServoXacros/#731-inertial-macros-y-servo-materials","text":"Estos archivos son bastante similares a los vistos en el ejemplo del robot diferencial, las Inertial macros siempre depender\u00e1n de la complejidad geom\u00e9trica del robot: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> Como se puede observar, es literalmente la misma macro empleada en el robot diferencial al utilizarse las mismas figur\u00e1s volum\u00e9tricas. Para la parte de los materiales del robot, tambi\u00e9n se realizaron de manera equivalente como en el robot diferencial: <?xml version=\"1.0\"?> <!-- Copied from ROS1 example: https://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/materials.xacro --> <robot> <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> </robot>","title":"7.3.1. Inertial Macros y Servo materials"},{"location":"5-1-ServoXacros/#732-servo-description","text":"En el xacro de servo description se tiene TODO el URDF del servo empleado en el repositorio. Para esto primero se incluyen las macros previamente expuestas: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <xacro:include filename=\"$(find servo_hardware)/urdf/inertial_macros.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.materials.xacro\" /> Luego se empieza con la definici\u00f3n de los links y joints primero con el MOTOR o CHASIS del servo. <!-- BASE LINK --> <link name=\"base_link\" /> <joint name=\"fixation\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"motor\"/> <origin xyz=\"0 0 0.267\"/> </joint> <!-- MOTOR LINK --> <link name=\"motor\"> <visual> <origin xyz=\"0.0 0.0535 -0.1535\"/> <geometry> <box size=\"0.118 0.225 0.227\"/> </geometry> <material name=\"blue\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.025\"/> <geometry> <cylinder radius=\"0.059\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.063 -0.025\"/> <geometry> <cylinder radius=\"0.025\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.0535 -0.0955\"/> <geometry> <box size=\"0.118 0.319 0.025\"/> </geometry> </visual> <collision> <origin xyz=\"0.0 0.0535 -0.1335\"/> <geometry> <box size=\"0.118 0.319 0.267\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.15\" x=\"0.118\" y=\"0.319\" z=\"0.267\"> <origin xyz=\"0.0 0.0535 -0.1335\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> Y luego con el ARM del servo o PLUMILLA <!-- ARM LINK --> <joint name=\"servo_joint\" type=\"revolute\"> <limit lower=\"-${pi/2}\" upper=\"${pi/2}\" effort=\"0.0\" velocity=\"0.0\"/> <parent link=\"motor\"/> <child link=\"arm\"/> <origin xyz=\"0 0 0.042\" rpy=\"0 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"arm\"> <visual> <origin xyz=\"0.0 0.0 -0.027\"/> <geometry> <cylinder radius=\"0.023\" length=\"0.03\"/> </geometry> <material name=\"white\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.021\"/> <geometry> <cylinder radius=\"0.05\" length=\"0.054\"/> </geometry> </visual> <visual> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.254 0.08 0.02\"/> </geometry> </visual> <collision> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.304 0.08 0.02\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.023\" radius=\"0.05\" length=\"0.03\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> </robot>","title":"7.3.2. Servo description"},{"location":"5-1-ServoXacros/#74-servo-simulated-y-servo-urdf","text":"Por \u00faltimo, se tienen dos xacros para las dos aplicaciones previamente mencionadas del robot","title":"7.4. Servo simulated y servo urdf"},{"location":"5-1-ServoXacros/#741-servo-simulated","text":"Este xacro se emplea \u00fanicamente para simular el servo en Gazebo , por lo que, en este archivo se incluyen los archivos necesarios para la simulaci\u00f3n; es decir, servo.description.xacro y servo.gazebo.xacro <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/gazebo/servo.gazebo.xacro\" /> </robot>","title":"7.4.1. Servo simulated"},{"location":"5-1-ServoXacros/#742-servo-urdf","text":"Y por otro lado, el servo.urdf.xacro incluye los archivos necesarios para realizar al aplicaci\u00f3n con el servo real ( servo.description.xacro y servo.ros2_control.xacro ) <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/ros2_control/servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" prefix=\"\" /> </robot>","title":"7.4.2. Servo urdf"},{"location":"5-2-ServoControllers/","text":"8. Servo Controllers Controladores y gazebo","title":"8. Servo Controllers"},{"location":"5-2-ServoControllers/#8-servo-controllers","text":"Controladores y gazebo","title":"8. Servo Controllers"},{"location":"5-3-ServoMoveIt/","text":"9. Servo Moveit Archivos de moveit","title":"9. Servo Moveit"},{"location":"5-3-ServoMoveIt/#9-servo-moveit","text":"Archivos de moveit","title":"9. Servo Moveit"},{"location":"5-4-ServoHardware%20y%20arduino/","text":"10. Servo hardware Harware y arduino de servo","title":"10. Servo hardware"},{"location":"5-4-ServoHardware%20y%20arduino/#10-servo-hardware","text":"Harware y arduino de servo","title":"10. Servo hardware"},{"location":"5-5-ServoLaunch/","text":"11. Servo launch Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada `generate_launch_description` que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el servo REAL gazebo.launch.py: Archivo Launch para realizar el control del servo en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un servo FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del servo ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py . 11.1. Mock Launch El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el contorl de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_mock.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[\"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"world\", \"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) servo_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"servo_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, servo_controller_spawner, ] ) 11.2. Gazebo Launch En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo y el Serial Device para la posici\u00f3n del servo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) # Command-line arguments serial_arg = DeclareLaunchArgument( \"port\", default_value=\"/dev/ttyACM0\", description=\"Puerto comunicacion serial\" ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\":True} moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_gazebo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description','-entity', 'servo'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SERVO_CONTROLLER delayed_servo_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[servo_controller_spawner], ) ) 11.3. Demo Launch El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar servo_mock.urdf.xacro , se toma el servo.urdf.xacro de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un servo FALSO sino el plugin constituido en C++ para el servo REAL .","title":"11. Servo launch"},{"location":"5-5-ServoLaunch/#11-servo-launch","text":"Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada `generate_launch_description` que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el servo REAL gazebo.launch.py: Archivo Launch para realizar el control del servo en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un servo FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del servo ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py .","title":"11. Servo launch"},{"location":"5-5-ServoLaunch/#111-mock-launch","text":"El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el contorl de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_mock.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[\"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"world\", \"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) servo_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"servo_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, servo_controller_spawner, ] )","title":"11.1. Mock Launch"},{"location":"5-5-ServoLaunch/#112-gazebo-launch","text":"En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo y el Serial Device para la posici\u00f3n del servo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) # Command-line arguments serial_arg = DeclareLaunchArgument( \"port\", default_value=\"/dev/ttyACM0\", description=\"Puerto comunicacion serial\" ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\":True} moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_gazebo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description','-entity', 'servo'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SERVO_CONTROLLER delayed_servo_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[servo_controller_spawner], ) )","title":"11.2. Gazebo Launch"},{"location":"5-5-ServoLaunch/#113-demo-launch","text":"El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar servo_mock.urdf.xacro , se toma el servo.urdf.xacro de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un servo FALSO sino el plugin constituido en C++ para el servo REAL .","title":"11.3. Demo Launch"},{"location":"6-0-SCARA/","text":"12. SCARA Introducci\u00f3n a robot SCARA con github y adaptaciones del servo Un robot SCARA tambi\u00e9n llamado Robot de Montaje con Cumplimiento Selectivo de Brazo, es un tipo espec\u00edfico de robot industrial utilizado com\u00fanmente en aplicaciones de ensamblaje, manipulaci\u00f3n y posicionamiento en la industria manufacturera. Este tipo de robot tiene un dise\u00f1o de brazo articulado que se caracteriza por su capacidad para moverse en un plano horizontal, similar al movimiento de un brazo humano.","title":"12. SCARA"},{"location":"6-0-SCARA/#12-scara","text":"Introducci\u00f3n a robot SCARA con github y adaptaciones del servo Un robot SCARA tambi\u00e9n llamado Robot de Montaje con Cumplimiento Selectivo de Brazo, es un tipo espec\u00edfico de robot industrial utilizado com\u00fanmente en aplicaciones de ensamblaje, manipulaci\u00f3n y posicionamiento en la industria manufacturera. Este tipo de robot tiene un dise\u00f1o de brazo articulado que se caracteriza por su capacidad para moverse en un plano horizontal, similar al movimiento de un brazo humano.","title":"12. SCARA"},{"location":"9-0-Anexos/","text":"Anexos xxxxxx","title":"Anexos"},{"location":"9-0-Anexos/#anexos","text":"xxxxxx","title":"Anexos"},{"location":"Ros2%20installation/","text":"Ros2 Installation for Ubuntu Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal: Setup Sources Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null Install ROS 2 packages We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y Environment setup Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc Verify the installation We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener Troubleshooting When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"Ros2 Installation for Ubuntu"},{"location":"Ros2%20installation/#ros2-installation-for-ubuntu","text":"Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal:","title":"Ros2 Installation for Ubuntu"},{"location":"Ros2%20installation/#setup-sources","text":"Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null","title":"Setup Sources"},{"location":"Ros2%20installation/#install-ros-2-packages","text":"We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y","title":"Install ROS 2 packages"},{"location":"Ros2%20installation/#environment-setup","text":"Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc","title":"Environment setup"},{"location":"Ros2%20installation/#verify-the-installation","text":"We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener","title":"Verify the installation"},{"location":"Ros2%20installation/#troubleshooting","text":"When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"Troubleshooting"}]}