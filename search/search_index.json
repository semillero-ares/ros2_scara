{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2 1.1. Introducci\u00f3n Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica 1.2. Descripci\u00f3n del proyecto Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2. 1.3. Objetivos de proyecto - Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso. 1.4. Etapas del proyecto - Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos. Requisitos principales del proyecto - Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Home"},{"location":"#brazo-robotico-controlado-por-ros-2","text":"","title":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2"},{"location":"#11-introduccion","text":"Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica","title":"1.1. Introducci\u00f3n"},{"location":"#12-descripcion-del-proyecto","text":"Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2.","title":"1.2. Descripci\u00f3n del proyecto"},{"location":"#13-objetivos-de-proyecto","text":"- Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso.","title":"1.3. Objetivos de proyecto"},{"location":"#14-etapas-del-proyecto","text":"- Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos.","title":"1.4. Etapas del proyecto"},{"location":"#requisitos-principales-del-proyecto","text":"- Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Requisitos principales del proyecto"},{"location":"1-0-Ros2%20installation/","text":"1. Ros2 Installation for Ubuntu Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal: Setup Sources Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null Install ROS 2 packages We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y Environment setup Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc Verify the installation We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener Troubleshooting When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"1. Ros2 Installation for Ubuntu"},{"location":"1-0-Ros2%20installation/#1-ros2-installation-for-ubuntu","text":"Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal:","title":"1. Ros2 Installation for Ubuntu"},{"location":"1-0-Ros2%20installation/#setup-sources","text":"Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null","title":"Setup Sources"},{"location":"1-0-Ros2%20installation/#install-ros-2-packages","text":"We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y","title":"Install ROS 2 packages"},{"location":"1-0-Ros2%20installation/#environment-setup","text":"Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc","title":"Environment setup"},{"location":"1-0-Ros2%20installation/#verify-the-installation","text":"We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener","title":"Verify the installation"},{"location":"1-0-Ros2%20installation/#troubleshooting","text":"When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"Troubleshooting"},{"location":"2-0-Requisitos/","text":"2. Requisitos software Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"2. Requisitos software"},{"location":"2-0-Requisitos/#2-requisitos-software","text":"Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"2. Requisitos software"},{"location":"3-0-primerosPasosRos/","text":"3. Primeros pasos con ROS 3.1. Creando un paquete en ROS Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) . 3.2. Clonar un paquete de Github A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"3. Primeros pasos con ROS"},{"location":"3-0-primerosPasosRos/#3-primeros-pasos-con-ros","text":"","title":"3. Primeros pasos con ROS"},{"location":"3-0-primerosPasosRos/#31-creando-un-paquete-en-ros","text":"Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) .","title":"3.1. Creando un paquete en ROS"},{"location":"3-0-primerosPasosRos/#32-clonar-un-paquete-de-github","text":"A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"3.2. Clonar un paquete de Github"},{"location":"4-0-Canal%20de%20referencia/","text":"4. Canal de referencia Para toda la elaboraci\u00f3n del proyecto, adem\u00e1s de utilizar librer\u00edas oficiales de las herramientas empleadas, se utilizaron videos de diversos canales de youtube. Sin embargo, para toda la conceptualizaci\u00f3n general de conocimientos para el proyecto, se emple\u00f3 el siguiente canal de youtube: Particularmente, se utiliz\u00f3 la siguiente la playlist Building a mobile robot . En este canal se realiza la simulaci\u00f3n y construcci\u00f3n de un robot diferencial; claramente al compararlo con el proyecto presentado tienen objetivos muy diferentes, pero al llevarse con las mismas herramientas y hasta por el mismo _camino_, se decidi\u00f3 tomar de referencia como conceptualizaci\u00f3n y hasta entrenamiento para la elaboraci\u00f3n del proyecto principal. Seg\u00fan esto, inicialmente se realiz\u00f3 el mismo proceso mostrado en el canal con el robot diferencial. Con esto realizado, se repitir\u00eda el mismo proceso pero con un servomotor; se tom\u00f3 este enfoque porque el SCARA est\u00e1 construido con _motores de paso_ con comportamiento similar a los servomotores; por lo que, al realizar el control con un servomotor, bastar\u00eda con _adaptar_ el proyecto al SCARA.","title":"4. Canal de referencia"},{"location":"4-0-Canal%20de%20referencia/#4-canal-de-referencia","text":"Para toda la elaboraci\u00f3n del proyecto, adem\u00e1s de utilizar librer\u00edas oficiales de las herramientas empleadas, se utilizaron videos de diversos canales de youtube. Sin embargo, para toda la conceptualizaci\u00f3n general de conocimientos para el proyecto, se emple\u00f3 el siguiente canal de youtube: Particularmente, se utiliz\u00f3 la siguiente la playlist Building a mobile robot . En este canal se realiza la simulaci\u00f3n y construcci\u00f3n de un robot diferencial; claramente al compararlo con el proyecto presentado tienen objetivos muy diferentes, pero al llevarse con las mismas herramientas y hasta por el mismo _camino_, se decidi\u00f3 tomar de referencia como conceptualizaci\u00f3n y hasta entrenamiento para la elaboraci\u00f3n del proyecto principal. Seg\u00fan esto, inicialmente se realiz\u00f3 el mismo proceso mostrado en el canal con el robot diferencial. Con esto realizado, se repitir\u00eda el mismo proceso pero con un servomotor; se tom\u00f3 este enfoque porque el SCARA est\u00e1 construido con _motores de paso_ con comportamiento similar a los servomotores; por lo que, al realizar el control con un servomotor, bastar\u00eda con _adaptar_ el proyecto al SCARA.","title":"4. Canal de referencia"},{"location":"4-1-URDF/","text":"5. URDF Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_. 5.1. Setup Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot. 5.2. Ejemplo URDF con Robot diferencial Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba 5.2.1. Creando un archivo URDF En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF. 5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5. URDF"},{"location":"4-1-URDF/#5-urdf","text":"Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_.","title":"5. URDF"},{"location":"4-1-URDF/#51-setup","text":"Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot.","title":"5.1. Setup"},{"location":"4-1-URDF/#52-ejemplo-urdf-con-robot-diferencial","text":"Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba","title":"5.2. Ejemplo URDF con Robot diferencial"},{"location":"4-1-URDF/#521-creando-un-archivo-urdf","text":"En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF.","title":"5.2.1. Creando un archivo URDF"},{"location":"4-1-URDF/#53-ejemplo-servomotor-urdf-con-plugin-de-solidworks","text":"Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks"},{"location":"5-0-Scara/","text":"6. Scara Seg\u00fan el ejemplo realizado en Solidworks con el servo, se procedi\u00f3 a realizar lo mismo pero con la modelaci\u00f3n del robot SCARA que se tiene a disposici\u00f3n Los robots Scara, conocidos com\u00fanmente como brazos rob\u00f3ticos, son un \u00e9xito de la automatizaci\u00f3n. Sus cuatro grados de libertad proporcionan mucha m\u00e1s velocidad, precisi\u00f3n y opciones que los manipuladores cartesianos est\u00e1ndar de tres ejes utilizados para la manipulaci\u00f3n. SCARA son las siglas de \"Selective Compilant Assembly Robot Arm\" (brazo rob\u00f3tico de ensamblaje selectivo). Se trata de un peque\u00f1o robot destinado a realizar tareas repetitivas con rapidez y precisi\u00f3n. Una de sus aplicaciones m\u00e1s comunes es \"recoger y colocar\" piezas del punto A a la posici\u00f3n B. Para esto se tiene la siguiente modelaci\u00f3n del SCARA: IMAGEN DEL SCARA MODELADO","title":"6. Scara"},{"location":"5-0-Scara/#6-scara","text":"Seg\u00fan el ejemplo realizado en Solidworks con el servo, se procedi\u00f3 a realizar lo mismo pero con la modelaci\u00f3n del robot SCARA que se tiene a disposici\u00f3n Los robots Scara, conocidos com\u00fanmente como brazos rob\u00f3ticos, son un \u00e9xito de la automatizaci\u00f3n. Sus cuatro grados de libertad proporcionan mucha m\u00e1s velocidad, precisi\u00f3n y opciones que los manipuladores cartesianos est\u00e1ndar de tres ejes utilizados para la manipulaci\u00f3n. SCARA son las siglas de \"Selective Compilant Assembly Robot Arm\" (brazo rob\u00f3tico de ensamblaje selectivo). Se trata de un peque\u00f1o robot destinado a realizar tareas repetitivas con rapidez y precisi\u00f3n. Una de sus aplicaciones m\u00e1s comunes es \"recoger y colocar\" piezas del punto A a la posici\u00f3n B. Para esto se tiene la siguiente modelaci\u00f3n del SCARA: IMAGEN DEL SCARA MODELADO","title":"6. Scara"},{"location":"5-1-ScaraXacros/","text":"7. Scara Xacros En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en Scara REAL , para esto se utiliza como plugin los archivos de scara Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: URDF extra\u00eddo de Solidworks seg\u00fan el ejemplo visualizado, este URDF usa meshes para parte del robot definida: antebrazo , base , brazo , dedo y mano . 7.1. Gazebo xacro Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el scara se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del scara. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio donde se incluye el URDF del Scara y su respectivo archivo de ros2_control <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"epson\"> <!-- Import scara urdf file --> <xacro:include filename=\"$(find scara)/urdf/urdf.xacro\" /> <!-- Import brazo ros2_control description --> <xacro:include filename=\"$(find scara_hardware)/config/ros2_control.xacro\" /> <xacro:hardware_component name=\"GazeboSimSystem\" plugin=\"gazebo_ros2_control/GazeboSystem\" /> Despu\u00e9s de esto se tiene la definici\u00f3n de colores para cada parte del robot definida <!-- Gazebo Colors --> <gazebo reference=\"base_link\"> <material>Gazebo/Orange</material> </gazebo> <gazebo reference=\"antebrazo\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"brazo\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"mano\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"dedo\"> <material>Gazebo/White</material> </gazebo> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find scara)/config/ros2_controllers.yaml</parameters> </plugin> </gazebo> </robot> 7.2. ROS2 Control El xacro del ros2 Control se utiliza cuando se desea controlar el scara REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. A diferencia del archivo del servo, el archivo del Scara es m\u00e1s robusto porque se necesitan especificar par\u00e1metros para cada joint como joint_controller_gain , joint_offset , joint3_minimum_time_period , etc. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"hardware_component\" params=\"name plugin\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>${plugin}</plugin> <!-- Joint1 --> <param name=\"joint1_name\">hombro</param> <param name=\"joint1_controller_gain\">50.0</param> <param name=\"joint1_counts_per_unit\">133005.464</param> <param name=\"joint1_ref\">-1.84</param> <param name=\"joint1_minimum_time_period\">1</param> <param name=\"joint1_maximum_time_period\">1000000</param> <param name=\"joint1_offset\">243400</param> <!-- Joint2 --> <param name=\"joint2_name\">codo</param> <param name=\"joint2_controller_gain\">50.0</param> <param name=\"joint2_counts_per_unit\">15481.74</param> <param name=\"joint2_ref\">2.57</param> <param name=\"joint2_minimum_time_period\">3</param> <param name=\"joint2_maximum_time_period\">1000000</param> <param name=\"joint2_offset\">-39850</param> <!-- Joint3 --> <param name=\"joint3_name\">muneca</param> <param name=\"joint3_controller_gain\">50.0</param> <param name=\"joint3_counts_per_unit\">1000.0</param> <param name=\"joint3_minimum_time_period\">1</param> <param name=\"joint3_maximum_time_period\">1000000</param> <param name=\"joint3_offset\">0</param> <!-- Joint4 --> <param name=\"joint4_name\">falange</param> <param name=\"joint4_controller_gain\">50.0</param> <param name=\"joint4_counts_per_unit\">1065200.0</param> <!-- 2 * 79890 / 0.15m --> <param name=\"joint4_minimum_time_period\">1</param> <param name=\"joint4_maximum_time_period\">1000000</param> <param name=\"joint4_offset\">0</param> Luego de esto se definen los par\u00e1metros para la serial_communication y las command interfaces y state interfaces <!-- Serial Communication --> <param name=\"loop_rate\">30</param> <param name=\"device\">/tmp/scara</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"echo\">true</param> </hardware> <joint name=\"hombro\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">-1.84</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"codo\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">2.57</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"falange\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">0.0</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"muneca\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">0.0</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> </ros2_control> </xacro:macro> </robot> 7.3. Calibraci\u00f3n para ROS2 Control Explicar proceso de calibraci\u00f3n","title":"7. Scara Xacros"},{"location":"5-1-ScaraXacros/#7-scara-xacros","text":"En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en Scara REAL , para esto se utiliza como plugin los archivos de scara Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: URDF extra\u00eddo de Solidworks seg\u00fan el ejemplo visualizado, este URDF usa meshes para parte del robot definida: antebrazo , base , brazo , dedo y mano .","title":"7. Scara Xacros"},{"location":"5-1-ScaraXacros/#71-gazebo-xacro","text":"Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el scara se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del scara. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio donde se incluye el URDF del Scara y su respectivo archivo de ros2_control <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"epson\"> <!-- Import scara urdf file --> <xacro:include filename=\"$(find scara)/urdf/urdf.xacro\" /> <!-- Import brazo ros2_control description --> <xacro:include filename=\"$(find scara_hardware)/config/ros2_control.xacro\" /> <xacro:hardware_component name=\"GazeboSimSystem\" plugin=\"gazebo_ros2_control/GazeboSystem\" /> Despu\u00e9s de esto se tiene la definici\u00f3n de colores para cada parte del robot definida <!-- Gazebo Colors --> <gazebo reference=\"base_link\"> <material>Gazebo/Orange</material> </gazebo> <gazebo reference=\"antebrazo\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"brazo\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"mano\"> <material>Gazebo/White</material> </gazebo> <gazebo reference=\"dedo\"> <material>Gazebo/White</material> </gazebo> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find scara)/config/ros2_controllers.yaml</parameters> </plugin> </gazebo> </robot>","title":"7.1. Gazebo xacro"},{"location":"5-1-ScaraXacros/#72-ros2-control","text":"El xacro del ros2 Control se utiliza cuando se desea controlar el scara REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. A diferencia del archivo del servo, el archivo del Scara es m\u00e1s robusto porque se necesitan especificar par\u00e1metros para cada joint como joint_controller_gain , joint_offset , joint3_minimum_time_period , etc. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"hardware_component\" params=\"name plugin\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>${plugin}</plugin> <!-- Joint1 --> <param name=\"joint1_name\">hombro</param> <param name=\"joint1_controller_gain\">50.0</param> <param name=\"joint1_counts_per_unit\">133005.464</param> <param name=\"joint1_ref\">-1.84</param> <param name=\"joint1_minimum_time_period\">1</param> <param name=\"joint1_maximum_time_period\">1000000</param> <param name=\"joint1_offset\">243400</param> <!-- Joint2 --> <param name=\"joint2_name\">codo</param> <param name=\"joint2_controller_gain\">50.0</param> <param name=\"joint2_counts_per_unit\">15481.74</param> <param name=\"joint2_ref\">2.57</param> <param name=\"joint2_minimum_time_period\">3</param> <param name=\"joint2_maximum_time_period\">1000000</param> <param name=\"joint2_offset\">-39850</param> <!-- Joint3 --> <param name=\"joint3_name\">muneca</param> <param name=\"joint3_controller_gain\">50.0</param> <param name=\"joint3_counts_per_unit\">1000.0</param> <param name=\"joint3_minimum_time_period\">1</param> <param name=\"joint3_maximum_time_period\">1000000</param> <param name=\"joint3_offset\">0</param> <!-- Joint4 --> <param name=\"joint4_name\">falange</param> <param name=\"joint4_controller_gain\">50.0</param> <param name=\"joint4_counts_per_unit\">1065200.0</param> <!-- 2 * 79890 / 0.15m --> <param name=\"joint4_minimum_time_period\">1</param> <param name=\"joint4_maximum_time_period\">1000000</param> <param name=\"joint4_offset\">0</param> Luego de esto se definen los par\u00e1metros para la serial_communication y las command interfaces y state interfaces <!-- Serial Communication --> <param name=\"loop_rate\">30</param> <param name=\"device\">/tmp/scara</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"echo\">true</param> </hardware> <joint name=\"hombro\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">-1.84</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"codo\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">2.57</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"falange\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">0.0</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> <joint name=\"muneca\"> <command_interface name=\"position\"/> <state_interface name=\"position\"> <param name=\"initial_value\">0.0</param> </state_interface> <state_interface name=\"velocity\"> <param name=\"initial_value\">0.0</param> </state_interface> </joint> </ros2_control> </xacro:macro> </robot>","title":"7.2. ROS2 Control"},{"location":"5-1-ScaraXacros/#73-calibracion-para-ros2-control","text":"Explicar proceso de calibraci\u00f3n","title":"7.3. Calibraci\u00f3n para ROS2 Control"},{"location":"5-2-ScaraControllers/","text":"8. Scara Controllers Los controladores son la parte m\u00e1s esencial de todo el proceso de simulaci\u00f3n y por supuesto, de control. Para toda la simulaci\u00f3n se emplean distintos archivos de controladores, los cuales se expresan en .yaml . Para la simulaci\u00f3n solamente se necesiten dos archivos de controladores: ros2_controllers.yaml ubicado en la carpeta config del paquete scara moveit_controllers.yaml ubicado en la carpeta config del paquete scara_moveit_config Como se pudo visualizar en los archivos xacro , los controladores se ingresan mediante un archivo de este tipo y depender\u00e1 de la simulaci\u00f3n que se desee realizar. Adem\u00e1s de esto, para la selecci\u00f3n del controlador se deben tener en cuenta varios detalles: command interfaces del robot state interfaces del robot Controladores a disposici\u00f3n para adaptar ( Repositorio ) 8.1 Estructura de archivo Los archivos de controlares est\u00e1n compuestos por dos partes: Declaraci\u00f3n de controlares y Descripci\u00f3n de controladores Declaraci\u00f3n de controladores Para el caso del servo se utilizaron los controladores: Joint trajectory controller y Joint state broadcaster , el primero de estos sirve para darle una trayectoria de puntos al controlador y est\u00e9 lo utilizar\u00e1 para mover robot y alcanzar estos puntos. Por otro lado, el Joint state broadcaster se utiliza para poder tener una conexi\u00f3n continua con el estado de los joints del robot, es recomedable utilizarlo siempre en estos casos. controller_manager: ros__parameters: update_rate: 100 # Hz scara_controller: type: joint_trajectory_controller/JointTrajectoryController joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster La declaraci\u00f3n como se puede visualizar esta compuesta meramente por el nombramiento de los controlares, utilizando la librer\u00eda y nombre indicado. Descripci\u00f3n de controladores Despu\u00e9s de esto, la descripci\u00f3n se basa en el ingreso de todos los par\u00e1metros que necesita el controlador para funcionar; es decir, se ingresan los joints , command interfaces y state interfaces , claramente si el controlador lo requiere. scara_controller: ros__parameters: interface_name: position command_interfaces: - position state_interfaces: - position - velocity joints: - hombro - codo - muneca - falange joint_state_broadcaster: ros__parameters: joints: - hombro - codo - muneca - falange En este caso el Joint trajectory controller requiere el ingreso de todos los par\u00e1metros mencionados, pero por otro lado el Joint state broadcaster solamente necesita los joints .","title":"8. Scara Controllers"},{"location":"5-2-ScaraControllers/#8-scara-controllers","text":"Los controladores son la parte m\u00e1s esencial de todo el proceso de simulaci\u00f3n y por supuesto, de control. Para toda la simulaci\u00f3n se emplean distintos archivos de controladores, los cuales se expresan en .yaml . Para la simulaci\u00f3n solamente se necesiten dos archivos de controladores: ros2_controllers.yaml ubicado en la carpeta config del paquete scara moveit_controllers.yaml ubicado en la carpeta config del paquete scara_moveit_config Como se pudo visualizar en los archivos xacro , los controladores se ingresan mediante un archivo de este tipo y depender\u00e1 de la simulaci\u00f3n que se desee realizar. Adem\u00e1s de esto, para la selecci\u00f3n del controlador se deben tener en cuenta varios detalles: command interfaces del robot state interfaces del robot Controladores a disposici\u00f3n para adaptar ( Repositorio )","title":"8. Scara Controllers"},{"location":"5-2-ScaraControllers/#81-estructura-de-archivo","text":"Los archivos de controlares est\u00e1n compuestos por dos partes: Declaraci\u00f3n de controlares y Descripci\u00f3n de controladores","title":"8.1 Estructura de archivo"},{"location":"5-2-ScaraControllers/#declaracion-de-controladores","text":"Para el caso del servo se utilizaron los controladores: Joint trajectory controller y Joint state broadcaster , el primero de estos sirve para darle una trayectoria de puntos al controlador y est\u00e9 lo utilizar\u00e1 para mover robot y alcanzar estos puntos. Por otro lado, el Joint state broadcaster se utiliza para poder tener una conexi\u00f3n continua con el estado de los joints del robot, es recomedable utilizarlo siempre en estos casos. controller_manager: ros__parameters: update_rate: 100 # Hz scara_controller: type: joint_trajectory_controller/JointTrajectoryController joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster La declaraci\u00f3n como se puede visualizar esta compuesta meramente por el nombramiento de los controlares, utilizando la librer\u00eda y nombre indicado.","title":"Declaraci\u00f3n de controladores"},{"location":"5-2-ScaraControllers/#descripcion-de-controladores","text":"Despu\u00e9s de esto, la descripci\u00f3n se basa en el ingreso de todos los par\u00e1metros que necesita el controlador para funcionar; es decir, se ingresan los joints , command interfaces y state interfaces , claramente si el controlador lo requiere. scara_controller: ros__parameters: interface_name: position command_interfaces: - position state_interfaces: - position - velocity joints: - hombro - codo - muneca - falange joint_state_broadcaster: ros__parameters: joints: - hombro - codo - muneca - falange En este caso el Joint trajectory controller requiere el ingreso de todos los par\u00e1metros mencionados, pero por otro lado el Joint state broadcaster solamente necesita los joints .","title":"Descripci\u00f3n de controladores"},{"location":"5-3-ScaraMoveIt/","text":"9. Scara Moveit Para utilizar MoveIt se requieren m\u00faltiples archivos para su funcionamiento, estos se enlistan a continuaci\u00f3n: 9.1 Archivos xacro gazebo.xacro mock.xacro servo.urdf servo.srdf Los archivos xacro a excepci\u00f3n del archivo scara.srdf , son los mismos previamente realizados y explicados, por lo que estos 3 archivos se basan simplemente en incluir los dem\u00e1s de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"scara\"> <!-- Import scara urdf file --> <xacro:include filename=\"$(find scara)/urdf/urdf.xacro\" /> <!-- Import servo ros2_control description --> <xacro:include filename=\"$(find scara_hardware)/config/ros2_control.xacro\" /> <xacro:hardware_component name=\"hardware_component\" plugin=\"scara_hardware/ScaraHardwareComponent\" /> </robot> Este es el c\u00f3digo del archivo scara.urdf en donde meramente se incluye el urdf del servo y se incluye la descripci\u00f3n del hardware del robot. Scara.srdf El \u00fanico archivo que no se hab\u00eda mencionado hasta el momento es el scara.srdf , este archivo es una descripci\u00f3n de la cadena del robot; es decir, c\u00f3mo est\u00e1 conectado el mismo por componentes. <?xml version=\"1.0\" ?> <!--This does not replace URDF, and is not an extension of URDF. This is a format for representing semantic information about the robot structure. A URDF file must exist for this robot as well, where the joints and the links that are referenced are defined --> <robot name=\"scara\"> <!--GROUPS: Representation of a set of joints and links. This can be useful for specifying DOF to plan for, defining arms, end effectors, etc--> <!--LINKS: When a link is specified, the parent joint of that link (if it exists) is automatically included--> <!--JOINTS: When a joint is specified, the child link of that joint (which will always exist) is automatically included--> <!--CHAINS: When a chain is specified, all the links along the chain (including endpoints) are included in the group. Additionally, all the joints that are parents to included links are also included. This means that joints along the chain and the parent joint of the base link are included in the group--> <!--SUBGROUPS: Groups can also be formed by referencing to already defined group names--> <group name=\"chain\"> <link name=\"world\"/> <link name=\"base_link\"/> <joint name=\"fijacion\"/> <link name=\"antebrazo\"/> <joint name=\"hombro\"/> <link name=\"brazo\"/> <joint name=\"codo\"/> <link name=\"mano\"/> <joint name=\"falange\"/> <link name=\"dedo\"/> <joint name=\"muneca\"/> <chain base_link=\"world\" tip_link=\"dedo\" /> </group> <!--GROUP STATES: Purpose: Define a named state for a particular group, in terms of joint values. This is useful to define states like 'folded arms'--> <group_state name=\"cero\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"0\" /> <joint name=\"hombro\" value=\"0\" /> <joint name=\"muneca\" value=\"0\" /> </group_state> <group_state name=\"izquierda\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-0.8852\" /> <joint name=\"hombro\" value=\"-0.538\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"derecha\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"2.2737\" /> <joint name=\"hombro\" value=\"2.482\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"adelante\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-2.3778\" /> <joint name=\"hombro\" value=\"0.8505\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"pick\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-2.3778\" /> <joint name=\"hombro\" value=\"0.8505\" /> <joint name=\"muneca\" value=\"0\" /> </group_state> <!--VIRTUAL JOINT: Purpose: this element defines a virtual joint between a robot link and an external frame of reference (considered fixed with respect to the robot)--> <virtual_joint name=\"virtual_joint\" type=\"fixed\" parent_frame=\"world\" child_link=\"world\" /> <!--DISABLE COLLISIONS: By default it is assumed that any link of the robot could potentially come into collision with any other link in the robot. This tag disables collision checking between a specified pair of links. --> <disable_collisions link1=\"antebrazo\" link2=\"base_link\" reason=\"Adjacent\" /> <disable_collisions link1=\"antebrazo\" link2=\"brazo\" reason=\"Adjacent\" /> <disable_collisions link1=\"base_link\" link2=\"mano\" reason=\"Never\" /> <disable_collisions link1=\"brazo\" link2=\"dedo\" reason=\"Never\" /> <disable_collisions link1=\"brazo\" link2=\"mano\" reason=\"Adjacent\" /> <disable_collisions link1=\"dedo\" link2=\"mano\" reason=\"Adjacent\" /> </robot> Como se puede observar, primero se enlista el grupo o cadena del robot bajo el nombre group name en donde se enlista toda la cadena de joints y links del robot. Luego de esto se definen los group states que son b\u00e1sicamente algunos estados del robot, estas vendr\u00edan siendo unas posiciones determinadas para el movimiento del mismo; y por \u00faltimo se pueden definir dos cosas virtual joint en donde se establece un joint entre el robot y el mundo para que no vuele el robot en la simulaci\u00f3n y disable collisions en donde se definen que joints no pueden chocar por ser adyacentes o simplemente ser imposible su colisi\u00f3n. 9.2 Archivos yaml chomp_planning.yaml ompl_planning.yaml pliz_cartesian_limits.yaml sensors.yaml moveit_controllers.yaml joint_limits.yaml kinematics.yaml Anteriormente, los archivos yaml pod\u00edan ser extra\u00eddos con el moveit assistant en ROS 1 , en el caso del servo y el scara se utilizaron los archivos extra\u00eddos previamente con ROS y se adaptaron a las necesidades propias. En MoveIt un robot se puede mover con diferentes planners , tales como chomp , ompl y pliz , estos se atribuyen a los 3 primeros archivos yaml , cada uno se diferencia en el objetivo que se requiera, por ejemplo para un movimiento con coordenadas vendr\u00eda siendo mejor un pliz ; sin embargo, en el proyecto inicialmente se utiliz\u00f3 el ompl . El archivo de sensors.yaml actualmente se encuentra vac\u00edo teniendo en cuenta que no se tienen sensores integrados al robot, el archivo de moveit_controllers.yaml se integra el controlador default de moveit y el que utilizamos para controlar el servo; es decir, el Joint trajectory controller de la siguiente manera: Moveit controllers trajectory_execution: allowed_execution_duration_scaling: 1.2 allowed_goal_duration_margin: 0.5 allowed_start_tolerance: 0.01 moveit_controller_manager: moveit_simple_controller_manager/MoveItSimpleControllerManager moveit_simple_controller_manager: controller_names: - scara_controller scara_controller: action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - hombro - codo - muneca - falange Por \u00faltimo se tienen los archivos joint_limits.yaml y kinematics.yaml , para joint_limits.yaml se decriben los l\u00edmites de los joints en t\u00e9rminos meramente de velocidad y aceleraci\u00f3n (si aplica): Joint limits # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # For beginners, we downscale velocity and acceleration limits. # You can always specify higher scaling factors (<= 1.0) in your motion requests. # Increase the values below to 1.0 to always move at maximum speed. default_velocity_scaling_factor: 0.1 default_acceleration_scaling_factor: 0.1 # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: falange: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 codo: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 hombro: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 muneca: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 Y para kinematics.yaml se utiliza un plugin de moveit para su funcionamiento: Kinematics group_name: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.015","title":"9. Scara Moveit"},{"location":"5-3-ScaraMoveIt/#9-scara-moveit","text":"Para utilizar MoveIt se requieren m\u00faltiples archivos para su funcionamiento, estos se enlistan a continuaci\u00f3n:","title":"9. Scara Moveit"},{"location":"5-3-ScaraMoveIt/#91-archivos-xacro","text":"gazebo.xacro mock.xacro servo.urdf servo.srdf Los archivos xacro a excepci\u00f3n del archivo scara.srdf , son los mismos previamente realizados y explicados, por lo que estos 3 archivos se basan simplemente en incluir los dem\u00e1s de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"scara\"> <!-- Import scara urdf file --> <xacro:include filename=\"$(find scara)/urdf/urdf.xacro\" /> <!-- Import servo ros2_control description --> <xacro:include filename=\"$(find scara_hardware)/config/ros2_control.xacro\" /> <xacro:hardware_component name=\"hardware_component\" plugin=\"scara_hardware/ScaraHardwareComponent\" /> </robot> Este es el c\u00f3digo del archivo scara.urdf en donde meramente se incluye el urdf del servo y se incluye la descripci\u00f3n del hardware del robot.","title":"9.1 Archivos xacro"},{"location":"5-3-ScaraMoveIt/#scarasrdf","text":"El \u00fanico archivo que no se hab\u00eda mencionado hasta el momento es el scara.srdf , este archivo es una descripci\u00f3n de la cadena del robot; es decir, c\u00f3mo est\u00e1 conectado el mismo por componentes. <?xml version=\"1.0\" ?> <!--This does not replace URDF, and is not an extension of URDF. This is a format for representing semantic information about the robot structure. A URDF file must exist for this robot as well, where the joints and the links that are referenced are defined --> <robot name=\"scara\"> <!--GROUPS: Representation of a set of joints and links. This can be useful for specifying DOF to plan for, defining arms, end effectors, etc--> <!--LINKS: When a link is specified, the parent joint of that link (if it exists) is automatically included--> <!--JOINTS: When a joint is specified, the child link of that joint (which will always exist) is automatically included--> <!--CHAINS: When a chain is specified, all the links along the chain (including endpoints) are included in the group. Additionally, all the joints that are parents to included links are also included. This means that joints along the chain and the parent joint of the base link are included in the group--> <!--SUBGROUPS: Groups can also be formed by referencing to already defined group names--> <group name=\"chain\"> <link name=\"world\"/> <link name=\"base_link\"/> <joint name=\"fijacion\"/> <link name=\"antebrazo\"/> <joint name=\"hombro\"/> <link name=\"brazo\"/> <joint name=\"codo\"/> <link name=\"mano\"/> <joint name=\"falange\"/> <link name=\"dedo\"/> <joint name=\"muneca\"/> <chain base_link=\"world\" tip_link=\"dedo\" /> </group> <!--GROUP STATES: Purpose: Define a named state for a particular group, in terms of joint values. This is useful to define states like 'folded arms'--> <group_state name=\"cero\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"0\" /> <joint name=\"hombro\" value=\"0\" /> <joint name=\"muneca\" value=\"0\" /> </group_state> <group_state name=\"izquierda\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-0.8852\" /> <joint name=\"hombro\" value=\"-0.538\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"derecha\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"2.2737\" /> <joint name=\"hombro\" value=\"2.482\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"adelante\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-2.3778\" /> <joint name=\"hombro\" value=\"0.8505\" /> <joint name=\"muneca\" value=\"0.2\" /> </group_state> <group_state name=\"pick\" group=\"chain\"> <joint name=\"falange\" value=\"0\" /> <joint name=\"codo\" value=\"-2.3778\" /> <joint name=\"hombro\" value=\"0.8505\" /> <joint name=\"muneca\" value=\"0\" /> </group_state> <!--VIRTUAL JOINT: Purpose: this element defines a virtual joint between a robot link and an external frame of reference (considered fixed with respect to the robot)--> <virtual_joint name=\"virtual_joint\" type=\"fixed\" parent_frame=\"world\" child_link=\"world\" /> <!--DISABLE COLLISIONS: By default it is assumed that any link of the robot could potentially come into collision with any other link in the robot. This tag disables collision checking between a specified pair of links. --> <disable_collisions link1=\"antebrazo\" link2=\"base_link\" reason=\"Adjacent\" /> <disable_collisions link1=\"antebrazo\" link2=\"brazo\" reason=\"Adjacent\" /> <disable_collisions link1=\"base_link\" link2=\"mano\" reason=\"Never\" /> <disable_collisions link1=\"brazo\" link2=\"dedo\" reason=\"Never\" /> <disable_collisions link1=\"brazo\" link2=\"mano\" reason=\"Adjacent\" /> <disable_collisions link1=\"dedo\" link2=\"mano\" reason=\"Adjacent\" /> </robot> Como se puede observar, primero se enlista el grupo o cadena del robot bajo el nombre group name en donde se enlista toda la cadena de joints y links del robot. Luego de esto se definen los group states que son b\u00e1sicamente algunos estados del robot, estas vendr\u00edan siendo unas posiciones determinadas para el movimiento del mismo; y por \u00faltimo se pueden definir dos cosas virtual joint en donde se establece un joint entre el robot y el mundo para que no vuele el robot en la simulaci\u00f3n y disable collisions en donde se definen que joints no pueden chocar por ser adyacentes o simplemente ser imposible su colisi\u00f3n.","title":"Scara.srdf"},{"location":"5-3-ScaraMoveIt/#92-archivos-yaml","text":"chomp_planning.yaml ompl_planning.yaml pliz_cartesian_limits.yaml sensors.yaml moveit_controllers.yaml joint_limits.yaml kinematics.yaml Anteriormente, los archivos yaml pod\u00edan ser extra\u00eddos con el moveit assistant en ROS 1 , en el caso del servo y el scara se utilizaron los archivos extra\u00eddos previamente con ROS y se adaptaron a las necesidades propias. En MoveIt un robot se puede mover con diferentes planners , tales como chomp , ompl y pliz , estos se atribuyen a los 3 primeros archivos yaml , cada uno se diferencia en el objetivo que se requiera, por ejemplo para un movimiento con coordenadas vendr\u00eda siendo mejor un pliz ; sin embargo, en el proyecto inicialmente se utiliz\u00f3 el ompl . El archivo de sensors.yaml actualmente se encuentra vac\u00edo teniendo en cuenta que no se tienen sensores integrados al robot, el archivo de moveit_controllers.yaml se integra el controlador default de moveit y el que utilizamos para controlar el servo; es decir, el Joint trajectory controller de la siguiente manera:","title":"9.2 Archivos yaml"},{"location":"5-3-ScaraMoveIt/#moveit-controllers","text":"trajectory_execution: allowed_execution_duration_scaling: 1.2 allowed_goal_duration_margin: 0.5 allowed_start_tolerance: 0.01 moveit_controller_manager: moveit_simple_controller_manager/MoveItSimpleControllerManager moveit_simple_controller_manager: controller_names: - scara_controller scara_controller: action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - hombro - codo - muneca - falange Por \u00faltimo se tienen los archivos joint_limits.yaml y kinematics.yaml , para joint_limits.yaml se decriben los l\u00edmites de los joints en t\u00e9rminos meramente de velocidad y aceleraci\u00f3n (si aplica):","title":"Moveit controllers"},{"location":"5-3-ScaraMoveIt/#joint-limits","text":"# joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # For beginners, we downscale velocity and acceleration limits. # You can always specify higher scaling factors (<= 1.0) in your motion requests. # Increase the values below to 1.0 to always move at maximum speed. default_velocity_scaling_factor: 0.1 default_acceleration_scaling_factor: 0.1 # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: falange: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 codo: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 hombro: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 muneca: has_velocity_limits: true max_velocity: 1.0 has_acceleration_limits: true max_acceleration: 1.0 Y para kinematics.yaml se utiliza un plugin de moveit para su funcionamiento:","title":"Joint limits"},{"location":"5-3-ScaraMoveIt/#kinematics","text":"group_name: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.015","title":"Kinematics"},{"location":"5-4-ScaraHardware/","text":"10. Scara hardware El Hardware Component del Scara se compone de lo siguiente: Archivo scara_system.cpp en donde se define el sistema de hardware del robot, incluyendo la configuraci\u00f3n de controladores, la comunicaci\u00f3n de sensores y motores del robot (si aplica) y funciones espec\u00edficas Carpeta include donde se almacenan archivos de encabezado .h y .hpp en donde se declaran funciones, clases y estructuras utiliadas en el c\u00f3digo. Esta carpeta contiene 4 archivos importantes: arduino_comms.hpp en donde se contienen las definiciones y declaraciones relacionadas con la comunicaci\u00f3n entre el Scara y arduino joint.hpp en donde se define la clase o las estructuras relacionadas con los joints del robot scara_systema.hpp en donde se define la clase principal o estructura que representa el sistema del robot visibility_control.h que se utiliza para la exportaci\u00f3n de s\u00edmbolos en bibliotecas y asegurar as\u00ed su correcta compilaci\u00f3n y vinculaci\u00f3n. A continuaci\u00f3n se realiza una descripci\u00f3n de los archivos que componen el Hardware Component 10.1 scara_system.cpp Primero se incluyen todas las librer\u00edas necesarias para la definici\u00f3n del sistema del robot #include \"scara_hardware/scara_system.hpp\" #include <chrono> #include <cmath> #include <limits> #include <memory> #include <vector> #include \"hardware_interface/types/hardware_interface_type_values.hpp\" #include \"rclcpp/rclcpp.hpp\" Despu\u00e9s de esto se define un espacio de nombres llamado scara_hardware con un condicional inicial que se asegura de la correcta inicializaci\u00f3n del robot namespace scara_hardware { hardware_interface::CallbackReturn ScaraHardwareComponent::on_init( const hardware_interface::HardwareInfo &info) { if ( hardware_interface::SystemInterface::on_init(info) != hardware_interface::CallbackReturn::SUCCESS) { return hardware_interface::CallbackReturn::ERROR; } Luego de esto se definen todos los par\u00e1metros necesarios para cada joint de la siguiente manera: // Joint 1 std::string j1_name = info_.hardware_parameters[\"joint1_name\"]; double j1_gain = std::stof(info_.hardware_parameters[\"joint1_controller_gain\"]); double j1_counts = std::stof(info_.hardware_parameters[\"joint1_counts_per_unit\"]); double j1_ref = std::stof(info_.hardware_parameters[\"joint1_ref\"]); int j1_mintp = std::stoi(info_.hardware_parameters[\"joint1_minimum_time_period\"]); int j1_maxtp = std::stoi(info_.hardware_parameters[\"joint1_maximum_time_period\"]); int j1_offset = std::stoi(info_.hardware_parameters[\"joint1_offset\"]); joint1_.setup(j1_name, j1_gain, j1_counts, j1_ref, j1_mintp, j1_maxtp, j1_offset); Adem\u00e1s, se ingresan los par\u00e1metros para la comunicaci\u00f3n serial cfg_.loop_rate = std::stof(info_.hardware_parameters[\"loop_rate\"]); cfg_.device = info_.hardware_parameters[\"device\"]; cfg_.baud_rate = std::stoi(info_.hardware_parameters[\"baud_rate\"]); cfg_.timeout_ms = std::stoi(info_.hardware_parameters[\"timeout_ms\"]); cfg_.echo = info_.hardware_parameters[\"echo\"] == \"true\" || info_.hardware_parameters[\"echo\"] == \"1\"; Despu\u00e9s de esto se realiza un bucle para confirmar la informaci\u00f3n de los joints contenida en las command_interfaces y state_interfaces . Por ejemplo, a continuaci\u00f3n se confirma que las command_interfaces sea s\u00f3lo UNA : de POSITION (esto debe tener concordancia con la definici\u00f3n de los controladores del robot). for (const hardware_interface::ComponentInfo &joint : info_.joints) { // DiffBotSystem has exactly two states and one command interface on each joint if (joint.command_interfaces.size() != 1) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' has %zu command interfaces found. 1 expected.\", joint.name.c_str(), joint.command_interfaces.size()); return hardware_interface::CallbackReturn::ERROR; } if (joint.command_interfaces[0].name != hardware_interface::HW_IF_POSITION) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have %s command interfaces found. '%s' expected.\", joint.name.c_str(), joint.command_interfaces[0].name.c_str(), hardware_interface::HW_IF_POSITION); return hardware_interface::CallbackReturn::ERROR; } De igual manera se realiza con las state_interfaces confirmando que sean dos: POSITION y VELOCITY if (joint.state_interfaces.size() != 2) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' has %zu state interface. 2 expected.\", joint.name.c_str(), joint.state_interfaces.size()); return hardware_interface::CallbackReturn::ERROR; } if (joint.state_interfaces[0].name != hardware_interface::HW_IF_POSITION) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have '%s' as first state interface. '%s' expected.\", joint.name.c_str(), joint.state_interfaces[0].name.c_str(), hardware_interface::HW_IF_POSITION); return hardware_interface::CallbackReturn::ERROR; } if (joint.state_interfaces[1].name != hardware_interface::HW_IF_VELOCITY) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have '%s' as second state interface. '%s' expected.\", joint.name.c_str(), joint.state_interfaces[1].name.c_str(), hardware_interface::HW_IF_VELOCITY); return hardware_interface::CallbackReturn::ERROR; } } return hardware_interface::CallbackReturn::SUCCESS; } Luego se crea un vector para exportar las command_interfaces y state_interfaces de los joints del robot std::vector<hardware_interface::StateInterface> ScaraHardwareComponent::export_state_interfaces() { std::vector<hardware_interface::StateInterface> state_interfaces; state_interfaces.emplace_back(hardware_interface::StateInterface( joint1_.name, hardware_interface::HW_IF_POSITION, &joint1_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint1_.name, hardware_interface::HW_IF_VELOCITY, &joint1_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint2_.name, hardware_interface::HW_IF_POSITION, &joint2_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint2_.name, hardware_interface::HW_IF_VELOCITY, &joint2_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint3_.name, hardware_interface::HW_IF_POSITION, &joint3_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint3_.name, hardware_interface::HW_IF_VELOCITY, &joint3_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint4_.name, hardware_interface::HW_IF_POSITION, &joint4_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint4_.name, hardware_interface::HW_IF_VELOCITY, &joint4_.velocity)); return state_interfaces; } std::vector<hardware_interface::CommandInterface> ScaraHardwareComponent::export_command_interfaces() { std::vector<hardware_interface::CommandInterface> command_interfaces; command_interfaces.emplace_back(hardware_interface::CommandInterface( joint1_.name, hardware_interface::HW_IF_POSITION, &joint1_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint2_.name, hardware_interface::HW_IF_POSITION, &joint2_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint3_.name, hardware_interface::HW_IF_POSITION, &joint3_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint4_.name, hardware_interface::HW_IF_POSITION, &joint4_.ref)); return command_interfaces; } Luego se realiza la creaci\u00f3n de funciones como on_configure , on_cleanup , on_activate y on_deactivate hardware_interface::CallbackReturn ScaraHardwareComponent::on_configure( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Configuring ...please wait...\"); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.device)); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.baud_rate)); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.timeout_ms)); if (comms_.connected()) { comms_.disconnect(); } comms_.connect(cfg_.device, cfg_.baud_rate, cfg_.timeout_ms); RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully configured!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_cleanup( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Cleaning up ...please wait...\"); if (comms_.connected()) { comms_.disconnect(); } RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully cleaned up!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_activate( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Activating ...please wait...\"); if (!comms_.connected()) { return hardware_interface::CallbackReturn::ERROR; } RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully activated!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_deactivate( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Deactivating ...please wait...\"); RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully deactivated!\"); return hardware_interface::CallbackReturn::SUCCESS; } Luego de esto, se crea la funci\u00f3n read que tiene como objetivo leer los datos desde el hardware del robot SCARA y actualizar las variables internas que representan el estado de las articulaciones. Primero se verifica si la comunicaci\u00f3n con el hardware est\u00e1 establecida. hardware_interface::return_type ScaraHardwareComponent::read( const rclcpp::Time & /*time*/, const rclcpp::Duration &period) { if (!comms_.connected()) { return hardware_interface::return_type::ERROR; } Luego se crea un string con toda la informaci\u00f3n de las articulaciones en un archivo .CSV llamado ss double delta_seconds = period.seconds(); std::stringstream ss; ss << joint1_.direction_cmd << \",\"; ss << joint1_.period_cmd << \",\"; ss << joint2_.direction_cmd << \",\"; ss << joint2_.period_cmd << \",\"; ss << joint3_.direction_cmd << \",\"; ss << joint3_.period_cmd << \",\"; ss << joint4_.direction_cmd << \",\"; ss << joint4_.period_cmd << \"\\n\"; std::string response = comms_.send_msg(ss.str(),cfg_.echo); Luego de almacenada esta informaci\u00f3n se procesa esta respuesta para ser almacenadas en otras variables if (response.length() > 0) { std::string delimiter = \",\"; size_t del_pos = response.find(delimiter); std::string aux_value = response.substr(0, del_pos); joint1_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); del_pos = response.find(delimiter); aux_value = response.substr(0, del_pos); joint2_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); del_pos = response.find(delimiter); aux_value = response.substr(0, del_pos); joint3_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); joint4_.position_cnts = std::atoi(response.c_str()); } Despu\u00e9s se utiliza el m\u00e9todo loop para actualizar el estado de las articulaciones con base en la nueva informaci\u00f3n obtenida y el tiempo transcurrido. joint1_.loop(delta_seconds); joint2_.loop(delta_seconds); joint3_.loop(delta_seconds); joint4_.loop(delta_seconds); return hardware_interface::return_type::OK; } Luego, se escribe la funci\u00f3n write , que lo \u00fanico que hace es devolver un ok en el caso de estar conectado con el hardware del robot hardware_interface::return_type scara_hardware ::ScaraHardwareComponent::write( const rclcpp::Time & /*time*/, const rclcpp::Duration & /*period*/) { if (!comms_.connected()) { return hardware_interface::return_type::ERROR; } return hardware_interface::return_type::OK; } } Y por \u00faltimo, se incluye un plugin para exportar las clases necesarias, en este caso scara_hardware como ScaraHardwareComponent y hardware_interface como SystemInterface . #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS( scara_hardware::ScaraHardwareComponent, hardware_interface::SystemInterface) 10.2 scara_system.hpp Primero se incluyen las librer\u00edas y archivos necesarios; adem\u00e1s de definir el s\u00edmbolo SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #ifndef SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #define SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #include <memory> #include <string> #include <vector> #include \"hardware_interface/handle.hpp\" #include \"hardware_interface/hardware_info.hpp\" #include \"hardware_interface/system_interface.hpp\" #include \"hardware_interface/types/hardware_interface_return_values.hpp\" #include \"rclcpp/clock.hpp\" #include \"rclcpp/duration.hpp\" #include \"rclcpp/macros.hpp\" #include \"rclcpp/time.hpp\" #include \"rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\" #include \"rclcpp_lifecycle/state.hpp\" #include \"scara_hardware/visibility_control.h\" #include \"scara_hardware/arduino_comms.hpp\" #include \"scara_hardware/joint.hpp\" Se define un espacio llamado scara_hardware junto con la clase ScaraHardwareComponent ; adem\u00e1s, se crea una estructura llamada Config en donde se almacena la configuraci\u00f3n y los par\u00e1metros relacionados con el hardware del robot, como loop_rate , baud_rate , timeout_ms , etc. namespace scara_hardware { class ScaraHardwareComponent : public hardware_interface::SystemInterface { struct Config { float loop_rate = 0.0; std::string device = \"\"; int baud_rate = 0; int timeout_ms = 0; bool echo = false; }; Luego, se validan funciones como on_init , on_configure , export_state_interfaces , read , etc. public: RCLCPP_SHARED_PTR_DEFINITIONS(ScaraHardwareComponent); SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_init( const hardware_interface::HardwareInfo & info) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_configure( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_cleanup( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_activate( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_deactivate( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::return_type read( const rclcpp::Time & time, const rclcpp::Duration & period) override; SCARA_HARDWARE_PUBLIC hardware_interface::return_type write( const rclcpp::Time & time, const rclcpp::Duration & period) override; SCARA_HARDWARE_PUBLIC std::vector<hardware_interface::StateInterface> export_state_interfaces() override; SCARA_HARDWARE_PUBLIC std::vector<hardware_interface::CommandInterface> export_command_interfaces() override; Por \u00faltimo, se definen miembros utilizados en la clase descrita como ArduinoComms , Joint , Config , etc. Adem\u00e1s, se finaliza el espacio scara_hardware y la definici\u00f3n del s\u00edmbolo SCARA_HARDWARE__SERVO_SYSTEM_HPP_ . private: ArduinoComms comms_; Config cfg_; Joint joint1_; Joint joint2_; Joint joint3_; Joint joint4_; }; } // namespace scara_hardware #endif // SCARA_HARDWARE__SERVO_SYSTEM_HPP_ 10.3 arduino_comms.hpp El archivo arduino_comms.hpp se basa simplemente en recibir todos los par\u00e1metros pertinentes para el arduino, primero se incluyen las librer\u00edas como en los dem\u00e1s archivos #ifndef SCARA_HARDWARE_ARDUINO_COMMS_HPP #define SCARA_HARDWARE_ARDUINO_COMMS_HPP #include <sstream> #include <libserial/SerialPort.h> #include <iostream> Se define la funci\u00f3n convert_baud_rate LibSerial::BaudRate convert_baud_rate(int baud_rate) { // Just handle some common baud rates switch (baud_rate) { case 1200: return LibSerial::BaudRate::BAUD_1200; case 1800: return LibSerial::BaudRate::BAUD_1800; case 2400: return LibSerial::BaudRate::BAUD_2400; case 4800: return LibSerial::BaudRate::BAUD_4800; case 9600: return LibSerial::BaudRate::BAUD_9600; case 19200: return LibSerial::BaudRate::BAUD_19200; case 38400: return LibSerial::BaudRate::BAUD_38400; case 57600: return LibSerial::BaudRate::BAUD_57600; case 115200: return LibSerial::BaudRate::BAUD_115200; case 230400: return LibSerial::BaudRate::BAUD_230400; default: std::cout << \"Error! Baud rate \" << baud_rate << \" not supported! Default to 57600\" << std::endl; return LibSerial::BaudRate::BAUD_57600; } } Luego se empieza con la creaci\u00f3n de la clase ArduinoComms y funciones internas como connect , disconnect , connected , etc. class ArduinoComms { public: ArduinoComms() = default; void connect(const std::string &serial_device, int32_t baud_rate, int32_t timeout_ms) { timeout_ms_ = timeout_ms; serial_conn_.Open(serial_device); serial_conn_.SetBaudRate(convert_baud_rate(baud_rate)); } void disconnect() { serial_conn_.Close(); } bool connected() const { return serial_conn_.IsOpen(); } Despu\u00e9s se crea la funci\u00f3n send_msg para enviar un mensaje a trav\u00e9s de una conexi\u00f3n serial y recibir una respuesta std::string send_msg(const std::string &msg_to_send, bool print_output = false) { serial_conn_.FlushIOBuffers(); // Just in case serial_conn_.Write(msg_to_send); std::string response = \"\"; try { // Responses end with \\r\\n so we will read up to (and including) the \\n. serial_conn_.ReadLine(response, '\\n', timeout_ms_); } catch (const LibSerial::ReadTimeout &) { std::cerr << \"\\e[1;31m The ReadByte() call has timed out. \\e[0m\" << std::endl; } if (print_output) { std::string msg_sent = msg_to_send.substr(0, msg_to_send.length() - 1); std::cout << \"\\e[1;32m Sent: \" << msg_sent << \"\\e[0m\\n\\e[1;32m Recv: \" << response << \"\\e[0m\" << std::endl; } return response; } void send_empty_msg() { std::string response = send_msg(\"\\r\"); } Con esto se almacena informaci\u00f3n en la variable response en un tiempo establecido ( timeout_ms_ ), esta variable se utiliza en el archivo scara_system.cpp . Y con esto se finaliza el archivo con los miembros privados private: LibSerial::SerialPort serial_conn_; int timeout_ms_; }; #endif // SCARA_HARDWARE_ARDUINO_COMMS_HPP 10.4 joint.hpp Ahora con toda la definici\u00f3n de la clase Joint , primero como con los dem\u00e1s documentos se incluyen las librer\u00edas y archivos #ifndef SCARA_HARDWARE_JOINT_HPP #define SCARA_HARDWARE_JOINT_HPP #include <string> #include <cmath> Se definen las variables con su clase pertinente dentro de la inicializaci\u00f3n de la clase class Joint { public: std::string name = \"\"; double ref = 0; double error = 0; double gain = 0; // <------------- input parameter double cmd = 0; double counts_per_unit = 0; // <-- input parameter double velocity_cmd = 0; int period_cmd = 0; int direction_cmd = 0; int us_min = 1; // <-------------- input parameter int us_max = 10; // <------------- input parameter int position_cnts = 0; int position_offset = 0; // <----- input parameter double position = 0; double velocity = 0; Luego se ingresan todos los par\u00e1metros de la clase Joint Joint() = default; Joint( const std::string &joint_name, double controller_gain, double counts, double reference, int min, int max, int offset) { setup(joint_name, controller_gain, counts, reference, min, max, offset); } Junto con las funciones iniciales para buscar el control \u00f3ptimo del robot void setup( const std::string &joint_name, double controller_gain, double counts, double reference, int min, int max, int offset) { // M_PI es la variable de pi=3.14159 name = joint_name; gain = controller_gain; counts_per_unit = counts; ref = reference; us_min = min; us_max = max; position_offset = offset; } void loop(double dt){ measure(dt); control(); } Con esto se definen todos los miembros privados de la clase en donde se definen distintas funciones para realizar el control \u00f3ptimo de las posiciones de las articulaciones del robot para finalizar el archivo. private: int position_delta_ = 0; double calc_position(){ position_delta_ = position_cnts - position_offset; return (double) position_delta_ / counts_per_unit; } void measure(double dt){ double pos_prev = position; position = calc_position(); velocity = (position - pos_prev) / dt; } void control(){ error = ref - position; cmd = gain*error; velocity_cmd = cmd*counts_per_unit; if(velocity_cmd == 0){ period_cmd = 0; }else{ if(velocity_cmd>0){ direction_cmd = 1; }else{ direction_cmd = 0; } period_cmd = (int) (1000000/velocity_cmd); period_cmd = fmin(fmax(abs(period_cmd),us_min),us_max); } } }; #endif // SCARA_HARDWARE_JOINT_HPP 10.5 visibility_control.h Por \u00faltimo el archivo visibility_control.h , este archivo de encabezado se utiliza para definir directivas de preprocesador que gestionan la visibilidad de los s\u00edmbolos (funciones, variables, clases, etc.) en una biblioteca o m\u00f3dulo de c\u00f3digo. La visibilidad de los s\u00edmbolos se refiere a si esos s\u00edmbolos son accesibles desde fuera de la biblioteca o m\u00f3dulo. #ifndef SCARA_HARDWARE__VISIBILITY_CONTROL_H_ #define SCARA_HARDWARE__VISIBILITY_CONTROL_H_ #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define SCARA_HARDWARE_EXPORT __attribute__((dllexport)) #define SCARA_HARDWARE_IMPORT __attribute__((dllimport)) #else #define SCARA_HARDWARE_EXPORT __declspec(dllexport) #define SCARA_HARDWARE_IMPORT __declspec(dllimport) #endif #ifdef SCARA_HARDWARE_BUILDING_DLL #define SCARA_HARDWARE_PUBLIC SCARA_HARDWARE_EXPORT #else #define SCARA_HARDWARE_PUBLIC SCARA_HARDWARE_IMPORT #endif #define SCARA_HARDWARE_PUBLIC_TYPE SCARA_HARDWARE_PUBLIC #define SCARA_HARDWARE_LOCAL #else #define SCARA_HARDWARE_EXPORT __attribute__((visibility(\"default\"))) #define SCARA_HARDWARE_IMPORT #if __GNUC__ >= 4 #define SCARA_HARDWARE_PUBLIC __attribute__((visibility(\"default\"))) #define SCARA_HARDWARE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define SCARA_HARDWARE_PUBLIC #define SCARA_HARDWARE_LOCAL #endif #define SCARA_HARDWARE_PUBLIC_TYPE #endif #endif // SCARA_HARDWARE__VISIBILITY_CONTROL_H_","title":"10. Scara hardware"},{"location":"5-4-ScaraHardware/#10-scara-hardware","text":"El Hardware Component del Scara se compone de lo siguiente: Archivo scara_system.cpp en donde se define el sistema de hardware del robot, incluyendo la configuraci\u00f3n de controladores, la comunicaci\u00f3n de sensores y motores del robot (si aplica) y funciones espec\u00edficas Carpeta include donde se almacenan archivos de encabezado .h y .hpp en donde se declaran funciones, clases y estructuras utiliadas en el c\u00f3digo. Esta carpeta contiene 4 archivos importantes: arduino_comms.hpp en donde se contienen las definiciones y declaraciones relacionadas con la comunicaci\u00f3n entre el Scara y arduino joint.hpp en donde se define la clase o las estructuras relacionadas con los joints del robot scara_systema.hpp en donde se define la clase principal o estructura que representa el sistema del robot visibility_control.h que se utiliza para la exportaci\u00f3n de s\u00edmbolos en bibliotecas y asegurar as\u00ed su correcta compilaci\u00f3n y vinculaci\u00f3n. A continuaci\u00f3n se realiza una descripci\u00f3n de los archivos que componen el Hardware Component","title":"10. Scara hardware"},{"location":"5-4-ScaraHardware/#101-scara_systemcpp","text":"Primero se incluyen todas las librer\u00edas necesarias para la definici\u00f3n del sistema del robot #include \"scara_hardware/scara_system.hpp\" #include <chrono> #include <cmath> #include <limits> #include <memory> #include <vector> #include \"hardware_interface/types/hardware_interface_type_values.hpp\" #include \"rclcpp/rclcpp.hpp\" Despu\u00e9s de esto se define un espacio de nombres llamado scara_hardware con un condicional inicial que se asegura de la correcta inicializaci\u00f3n del robot namespace scara_hardware { hardware_interface::CallbackReturn ScaraHardwareComponent::on_init( const hardware_interface::HardwareInfo &info) { if ( hardware_interface::SystemInterface::on_init(info) != hardware_interface::CallbackReturn::SUCCESS) { return hardware_interface::CallbackReturn::ERROR; } Luego de esto se definen todos los par\u00e1metros necesarios para cada joint de la siguiente manera: // Joint 1 std::string j1_name = info_.hardware_parameters[\"joint1_name\"]; double j1_gain = std::stof(info_.hardware_parameters[\"joint1_controller_gain\"]); double j1_counts = std::stof(info_.hardware_parameters[\"joint1_counts_per_unit\"]); double j1_ref = std::stof(info_.hardware_parameters[\"joint1_ref\"]); int j1_mintp = std::stoi(info_.hardware_parameters[\"joint1_minimum_time_period\"]); int j1_maxtp = std::stoi(info_.hardware_parameters[\"joint1_maximum_time_period\"]); int j1_offset = std::stoi(info_.hardware_parameters[\"joint1_offset\"]); joint1_.setup(j1_name, j1_gain, j1_counts, j1_ref, j1_mintp, j1_maxtp, j1_offset); Adem\u00e1s, se ingresan los par\u00e1metros para la comunicaci\u00f3n serial cfg_.loop_rate = std::stof(info_.hardware_parameters[\"loop_rate\"]); cfg_.device = info_.hardware_parameters[\"device\"]; cfg_.baud_rate = std::stoi(info_.hardware_parameters[\"baud_rate\"]); cfg_.timeout_ms = std::stoi(info_.hardware_parameters[\"timeout_ms\"]); cfg_.echo = info_.hardware_parameters[\"echo\"] == \"true\" || info_.hardware_parameters[\"echo\"] == \"1\"; Despu\u00e9s de esto se realiza un bucle para confirmar la informaci\u00f3n de los joints contenida en las command_interfaces y state_interfaces . Por ejemplo, a continuaci\u00f3n se confirma que las command_interfaces sea s\u00f3lo UNA : de POSITION (esto debe tener concordancia con la definici\u00f3n de los controladores del robot). for (const hardware_interface::ComponentInfo &joint : info_.joints) { // DiffBotSystem has exactly two states and one command interface on each joint if (joint.command_interfaces.size() != 1) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' has %zu command interfaces found. 1 expected.\", joint.name.c_str(), joint.command_interfaces.size()); return hardware_interface::CallbackReturn::ERROR; } if (joint.command_interfaces[0].name != hardware_interface::HW_IF_POSITION) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have %s command interfaces found. '%s' expected.\", joint.name.c_str(), joint.command_interfaces[0].name.c_str(), hardware_interface::HW_IF_POSITION); return hardware_interface::CallbackReturn::ERROR; } De igual manera se realiza con las state_interfaces confirmando que sean dos: POSITION y VELOCITY if (joint.state_interfaces.size() != 2) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' has %zu state interface. 2 expected.\", joint.name.c_str(), joint.state_interfaces.size()); return hardware_interface::CallbackReturn::ERROR; } if (joint.state_interfaces[0].name != hardware_interface::HW_IF_POSITION) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have '%s' as first state interface. '%s' expected.\", joint.name.c_str(), joint.state_interfaces[0].name.c_str(), hardware_interface::HW_IF_POSITION); return hardware_interface::CallbackReturn::ERROR; } if (joint.state_interfaces[1].name != hardware_interface::HW_IF_VELOCITY) { RCLCPP_FATAL( rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Joint '%s' have '%s' as second state interface. '%s' expected.\", joint.name.c_str(), joint.state_interfaces[1].name.c_str(), hardware_interface::HW_IF_VELOCITY); return hardware_interface::CallbackReturn::ERROR; } } return hardware_interface::CallbackReturn::SUCCESS; } Luego se crea un vector para exportar las command_interfaces y state_interfaces de los joints del robot std::vector<hardware_interface::StateInterface> ScaraHardwareComponent::export_state_interfaces() { std::vector<hardware_interface::StateInterface> state_interfaces; state_interfaces.emplace_back(hardware_interface::StateInterface( joint1_.name, hardware_interface::HW_IF_POSITION, &joint1_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint1_.name, hardware_interface::HW_IF_VELOCITY, &joint1_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint2_.name, hardware_interface::HW_IF_POSITION, &joint2_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint2_.name, hardware_interface::HW_IF_VELOCITY, &joint2_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint3_.name, hardware_interface::HW_IF_POSITION, &joint3_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint3_.name, hardware_interface::HW_IF_VELOCITY, &joint3_.velocity)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint4_.name, hardware_interface::HW_IF_POSITION, &joint4_.position)); state_interfaces.emplace_back(hardware_interface::StateInterface( joint4_.name, hardware_interface::HW_IF_VELOCITY, &joint4_.velocity)); return state_interfaces; } std::vector<hardware_interface::CommandInterface> ScaraHardwareComponent::export_command_interfaces() { std::vector<hardware_interface::CommandInterface> command_interfaces; command_interfaces.emplace_back(hardware_interface::CommandInterface( joint1_.name, hardware_interface::HW_IF_POSITION, &joint1_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint2_.name, hardware_interface::HW_IF_POSITION, &joint2_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint3_.name, hardware_interface::HW_IF_POSITION, &joint3_.ref)); command_interfaces.emplace_back(hardware_interface::CommandInterface( joint4_.name, hardware_interface::HW_IF_POSITION, &joint4_.ref)); return command_interfaces; } Luego se realiza la creaci\u00f3n de funciones como on_configure , on_cleanup , on_activate y on_deactivate hardware_interface::CallbackReturn ScaraHardwareComponent::on_configure( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Configuring ...please wait...\"); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.device)); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.baud_rate)); // RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), std::string(cfg_.timeout_ms)); if (comms_.connected()) { comms_.disconnect(); } comms_.connect(cfg_.device, cfg_.baud_rate, cfg_.timeout_ms); RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully configured!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_cleanup( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Cleaning up ...please wait...\"); if (comms_.connected()) { comms_.disconnect(); } RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully cleaned up!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_activate( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Activating ...please wait...\"); if (!comms_.connected()) { return hardware_interface::CallbackReturn::ERROR; } RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully activated!\"); return hardware_interface::CallbackReturn::SUCCESS; } hardware_interface::CallbackReturn ScaraHardwareComponent::on_deactivate( const rclcpp_lifecycle::State & /*previous_state*/) { RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Deactivating ...please wait...\"); RCLCPP_INFO(rclcpp::get_logger(\"ScaraHardwareComponent\"), \"Successfully deactivated!\"); return hardware_interface::CallbackReturn::SUCCESS; } Luego de esto, se crea la funci\u00f3n read que tiene como objetivo leer los datos desde el hardware del robot SCARA y actualizar las variables internas que representan el estado de las articulaciones. Primero se verifica si la comunicaci\u00f3n con el hardware est\u00e1 establecida. hardware_interface::return_type ScaraHardwareComponent::read( const rclcpp::Time & /*time*/, const rclcpp::Duration &period) { if (!comms_.connected()) { return hardware_interface::return_type::ERROR; } Luego se crea un string con toda la informaci\u00f3n de las articulaciones en un archivo .CSV llamado ss double delta_seconds = period.seconds(); std::stringstream ss; ss << joint1_.direction_cmd << \",\"; ss << joint1_.period_cmd << \",\"; ss << joint2_.direction_cmd << \",\"; ss << joint2_.period_cmd << \",\"; ss << joint3_.direction_cmd << \",\"; ss << joint3_.period_cmd << \",\"; ss << joint4_.direction_cmd << \",\"; ss << joint4_.period_cmd << \"\\n\"; std::string response = comms_.send_msg(ss.str(),cfg_.echo); Luego de almacenada esta informaci\u00f3n se procesa esta respuesta para ser almacenadas en otras variables if (response.length() > 0) { std::string delimiter = \",\"; size_t del_pos = response.find(delimiter); std::string aux_value = response.substr(0, del_pos); joint1_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); del_pos = response.find(delimiter); aux_value = response.substr(0, del_pos); joint2_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); del_pos = response.find(delimiter); aux_value = response.substr(0, del_pos); joint3_.position_cnts = std::atoi(aux_value.c_str()); response = response.substr(del_pos + delimiter.length()); joint4_.position_cnts = std::atoi(response.c_str()); } Despu\u00e9s se utiliza el m\u00e9todo loop para actualizar el estado de las articulaciones con base en la nueva informaci\u00f3n obtenida y el tiempo transcurrido. joint1_.loop(delta_seconds); joint2_.loop(delta_seconds); joint3_.loop(delta_seconds); joint4_.loop(delta_seconds); return hardware_interface::return_type::OK; } Luego, se escribe la funci\u00f3n write , que lo \u00fanico que hace es devolver un ok en el caso de estar conectado con el hardware del robot hardware_interface::return_type scara_hardware ::ScaraHardwareComponent::write( const rclcpp::Time & /*time*/, const rclcpp::Duration & /*period*/) { if (!comms_.connected()) { return hardware_interface::return_type::ERROR; } return hardware_interface::return_type::OK; } } Y por \u00faltimo, se incluye un plugin para exportar las clases necesarias, en este caso scara_hardware como ScaraHardwareComponent y hardware_interface como SystemInterface . #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS( scara_hardware::ScaraHardwareComponent, hardware_interface::SystemInterface)","title":"10.1 scara_system.cpp"},{"location":"5-4-ScaraHardware/#102-scara_systemhpp","text":"Primero se incluyen las librer\u00edas y archivos necesarios; adem\u00e1s de definir el s\u00edmbolo SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #ifndef SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #define SCARA_HARDWARE__SERVO_SYSTEM_HPP_ #include <memory> #include <string> #include <vector> #include \"hardware_interface/handle.hpp\" #include \"hardware_interface/hardware_info.hpp\" #include \"hardware_interface/system_interface.hpp\" #include \"hardware_interface/types/hardware_interface_return_values.hpp\" #include \"rclcpp/clock.hpp\" #include \"rclcpp/duration.hpp\" #include \"rclcpp/macros.hpp\" #include \"rclcpp/time.hpp\" #include \"rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp\" #include \"rclcpp_lifecycle/state.hpp\" #include \"scara_hardware/visibility_control.h\" #include \"scara_hardware/arduino_comms.hpp\" #include \"scara_hardware/joint.hpp\" Se define un espacio llamado scara_hardware junto con la clase ScaraHardwareComponent ; adem\u00e1s, se crea una estructura llamada Config en donde se almacena la configuraci\u00f3n y los par\u00e1metros relacionados con el hardware del robot, como loop_rate , baud_rate , timeout_ms , etc. namespace scara_hardware { class ScaraHardwareComponent : public hardware_interface::SystemInterface { struct Config { float loop_rate = 0.0; std::string device = \"\"; int baud_rate = 0; int timeout_ms = 0; bool echo = false; }; Luego, se validan funciones como on_init , on_configure , export_state_interfaces , read , etc. public: RCLCPP_SHARED_PTR_DEFINITIONS(ScaraHardwareComponent); SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_init( const hardware_interface::HardwareInfo & info) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_configure( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_cleanup( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_activate( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::CallbackReturn on_deactivate( const rclcpp_lifecycle::State & previous_state) override; SCARA_HARDWARE_PUBLIC hardware_interface::return_type read( const rclcpp::Time & time, const rclcpp::Duration & period) override; SCARA_HARDWARE_PUBLIC hardware_interface::return_type write( const rclcpp::Time & time, const rclcpp::Duration & period) override; SCARA_HARDWARE_PUBLIC std::vector<hardware_interface::StateInterface> export_state_interfaces() override; SCARA_HARDWARE_PUBLIC std::vector<hardware_interface::CommandInterface> export_command_interfaces() override; Por \u00faltimo, se definen miembros utilizados en la clase descrita como ArduinoComms , Joint , Config , etc. Adem\u00e1s, se finaliza el espacio scara_hardware y la definici\u00f3n del s\u00edmbolo SCARA_HARDWARE__SERVO_SYSTEM_HPP_ . private: ArduinoComms comms_; Config cfg_; Joint joint1_; Joint joint2_; Joint joint3_; Joint joint4_; }; } // namespace scara_hardware #endif // SCARA_HARDWARE__SERVO_SYSTEM_HPP_","title":"10.2 scara_system.hpp"},{"location":"5-4-ScaraHardware/#103-arduino_commshpp","text":"El archivo arduino_comms.hpp se basa simplemente en recibir todos los par\u00e1metros pertinentes para el arduino, primero se incluyen las librer\u00edas como en los dem\u00e1s archivos #ifndef SCARA_HARDWARE_ARDUINO_COMMS_HPP #define SCARA_HARDWARE_ARDUINO_COMMS_HPP #include <sstream> #include <libserial/SerialPort.h> #include <iostream> Se define la funci\u00f3n convert_baud_rate LibSerial::BaudRate convert_baud_rate(int baud_rate) { // Just handle some common baud rates switch (baud_rate) { case 1200: return LibSerial::BaudRate::BAUD_1200; case 1800: return LibSerial::BaudRate::BAUD_1800; case 2400: return LibSerial::BaudRate::BAUD_2400; case 4800: return LibSerial::BaudRate::BAUD_4800; case 9600: return LibSerial::BaudRate::BAUD_9600; case 19200: return LibSerial::BaudRate::BAUD_19200; case 38400: return LibSerial::BaudRate::BAUD_38400; case 57600: return LibSerial::BaudRate::BAUD_57600; case 115200: return LibSerial::BaudRate::BAUD_115200; case 230400: return LibSerial::BaudRate::BAUD_230400; default: std::cout << \"Error! Baud rate \" << baud_rate << \" not supported! Default to 57600\" << std::endl; return LibSerial::BaudRate::BAUD_57600; } } Luego se empieza con la creaci\u00f3n de la clase ArduinoComms y funciones internas como connect , disconnect , connected , etc. class ArduinoComms { public: ArduinoComms() = default; void connect(const std::string &serial_device, int32_t baud_rate, int32_t timeout_ms) { timeout_ms_ = timeout_ms; serial_conn_.Open(serial_device); serial_conn_.SetBaudRate(convert_baud_rate(baud_rate)); } void disconnect() { serial_conn_.Close(); } bool connected() const { return serial_conn_.IsOpen(); } Despu\u00e9s se crea la funci\u00f3n send_msg para enviar un mensaje a trav\u00e9s de una conexi\u00f3n serial y recibir una respuesta std::string send_msg(const std::string &msg_to_send, bool print_output = false) { serial_conn_.FlushIOBuffers(); // Just in case serial_conn_.Write(msg_to_send); std::string response = \"\"; try { // Responses end with \\r\\n so we will read up to (and including) the \\n. serial_conn_.ReadLine(response, '\\n', timeout_ms_); } catch (const LibSerial::ReadTimeout &) { std::cerr << \"\\e[1;31m The ReadByte() call has timed out. \\e[0m\" << std::endl; } if (print_output) { std::string msg_sent = msg_to_send.substr(0, msg_to_send.length() - 1); std::cout << \"\\e[1;32m Sent: \" << msg_sent << \"\\e[0m\\n\\e[1;32m Recv: \" << response << \"\\e[0m\" << std::endl; } return response; } void send_empty_msg() { std::string response = send_msg(\"\\r\"); } Con esto se almacena informaci\u00f3n en la variable response en un tiempo establecido ( timeout_ms_ ), esta variable se utiliza en el archivo scara_system.cpp . Y con esto se finaliza el archivo con los miembros privados private: LibSerial::SerialPort serial_conn_; int timeout_ms_; }; #endif // SCARA_HARDWARE_ARDUINO_COMMS_HPP","title":"10.3 arduino_comms.hpp"},{"location":"5-4-ScaraHardware/#104-jointhpp","text":"Ahora con toda la definici\u00f3n de la clase Joint , primero como con los dem\u00e1s documentos se incluyen las librer\u00edas y archivos #ifndef SCARA_HARDWARE_JOINT_HPP #define SCARA_HARDWARE_JOINT_HPP #include <string> #include <cmath> Se definen las variables con su clase pertinente dentro de la inicializaci\u00f3n de la clase class Joint { public: std::string name = \"\"; double ref = 0; double error = 0; double gain = 0; // <------------- input parameter double cmd = 0; double counts_per_unit = 0; // <-- input parameter double velocity_cmd = 0; int period_cmd = 0; int direction_cmd = 0; int us_min = 1; // <-------------- input parameter int us_max = 10; // <------------- input parameter int position_cnts = 0; int position_offset = 0; // <----- input parameter double position = 0; double velocity = 0; Luego se ingresan todos los par\u00e1metros de la clase Joint Joint() = default; Joint( const std::string &joint_name, double controller_gain, double counts, double reference, int min, int max, int offset) { setup(joint_name, controller_gain, counts, reference, min, max, offset); } Junto con las funciones iniciales para buscar el control \u00f3ptimo del robot void setup( const std::string &joint_name, double controller_gain, double counts, double reference, int min, int max, int offset) { // M_PI es la variable de pi=3.14159 name = joint_name; gain = controller_gain; counts_per_unit = counts; ref = reference; us_min = min; us_max = max; position_offset = offset; } void loop(double dt){ measure(dt); control(); } Con esto se definen todos los miembros privados de la clase en donde se definen distintas funciones para realizar el control \u00f3ptimo de las posiciones de las articulaciones del robot para finalizar el archivo. private: int position_delta_ = 0; double calc_position(){ position_delta_ = position_cnts - position_offset; return (double) position_delta_ / counts_per_unit; } void measure(double dt){ double pos_prev = position; position = calc_position(); velocity = (position - pos_prev) / dt; } void control(){ error = ref - position; cmd = gain*error; velocity_cmd = cmd*counts_per_unit; if(velocity_cmd == 0){ period_cmd = 0; }else{ if(velocity_cmd>0){ direction_cmd = 1; }else{ direction_cmd = 0; } period_cmd = (int) (1000000/velocity_cmd); period_cmd = fmin(fmax(abs(period_cmd),us_min),us_max); } } }; #endif // SCARA_HARDWARE_JOINT_HPP","title":"10.4 joint.hpp"},{"location":"5-4-ScaraHardware/#105-visibility_controlh","text":"Por \u00faltimo el archivo visibility_control.h , este archivo de encabezado se utiliza para definir directivas de preprocesador que gestionan la visibilidad de los s\u00edmbolos (funciones, variables, clases, etc.) en una biblioteca o m\u00f3dulo de c\u00f3digo. La visibilidad de los s\u00edmbolos se refiere a si esos s\u00edmbolos son accesibles desde fuera de la biblioteca o m\u00f3dulo. #ifndef SCARA_HARDWARE__VISIBILITY_CONTROL_H_ #define SCARA_HARDWARE__VISIBILITY_CONTROL_H_ #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define SCARA_HARDWARE_EXPORT __attribute__((dllexport)) #define SCARA_HARDWARE_IMPORT __attribute__((dllimport)) #else #define SCARA_HARDWARE_EXPORT __declspec(dllexport) #define SCARA_HARDWARE_IMPORT __declspec(dllimport) #endif #ifdef SCARA_HARDWARE_BUILDING_DLL #define SCARA_HARDWARE_PUBLIC SCARA_HARDWARE_EXPORT #else #define SCARA_HARDWARE_PUBLIC SCARA_HARDWARE_IMPORT #endif #define SCARA_HARDWARE_PUBLIC_TYPE SCARA_HARDWARE_PUBLIC #define SCARA_HARDWARE_LOCAL #else #define SCARA_HARDWARE_EXPORT __attribute__((visibility(\"default\"))) #define SCARA_HARDWARE_IMPORT #if __GNUC__ >= 4 #define SCARA_HARDWARE_PUBLIC __attribute__((visibility(\"default\"))) #define SCARA_HARDWARE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define SCARA_HARDWARE_PUBLIC #define SCARA_HARDWARE_LOCAL #endif #define SCARA_HARDWARE_PUBLIC_TYPE #endif #endif // SCARA_HARDWARE__VISIBILITY_CONTROL_H_","title":"10.5 visibility_control.h"},{"location":"5-5-ScaraLaunch/","text":"11. Scara launch Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada generate_launch_description que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el Scara REAL gazebo.launch.py: Archivo Launch para realizar el control del scara en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un scara FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del scara ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py . 11.1. Mock Launch El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el control de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, Shutdown from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/mock.xacro\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"scara_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], on_exit=Shutdown() ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[ \"--frame-id\",\"world\", \"--child-frame-id\",\"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"scara\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) scara_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"scara_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, scara_controller_spawner, ] ) 11.2. Gazebo Launch En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import Shutdown, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\": True} moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/gazebo.xacro\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description', '-entity', 'scara'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SCARA_CONTROLLER delayed_scara_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[scara_controller_spawner], ) ) 11.3. Demo Launch El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/scara.urdf\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar mock.xacro , se toma el scara.urdf de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un scara FALSO sino el plugin constituido en C++ para el scara REAL .","title":"11. Scara launch"},{"location":"5-5-ScaraLaunch/#11-scara-launch","text":"Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada generate_launch_description que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el Scara REAL gazebo.launch.py: Archivo Launch para realizar el control del scara en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un scara FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del scara ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py .","title":"11. Scara launch"},{"location":"5-5-ScaraLaunch/#111-mock-launch","text":"El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el control de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, Shutdown from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/mock.xacro\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"scara_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], on_exit=Shutdown() ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[ \"--frame-id\",\"world\", \"--child-frame-id\",\"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"scara\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) scara_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"scara_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, scara_controller_spawner, ] )","title":"11.1. Mock Launch"},{"location":"5-5-ScaraLaunch/#112-gazebo-launch","text":"En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import Shutdown, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\": True} moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/gazebo.xacro\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description', '-entity', 'scara'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SCARA_CONTROLLER delayed_scara_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[scara_controller_spawner], ) )","title":"11.2. Gazebo Launch"},{"location":"5-5-ScaraLaunch/#113-demo-launch","text":"El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"scara\") .robot_description(file_path=\"config/scara.urdf\") .robot_description_semantic(file_path=\"config/scara.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar mock.xacro , se toma el scara.urdf de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un scara FALSO sino el plugin constituido en C++ para el scara REAL .","title":"11.3. Demo Launch"}]}